''''

Эльдар

Классы в объектно-ориентированном программировании призваны описывать реально существующие
предметы и ситуации для представления их в виде объектов, обладающих как общим поведением, так и
уникальными особенностями.
Создание объекта на основе класса называется созданием экземпляра, т.е. данный объект является
экземпляром класса.
Классы упрощают реализацию серьезных проектов.


Создадим простой класс Dog, представляющий собаку — не какую-то конкретную, а собаку
вообще.
 Перечислим знания о собаках: есть кличка и возраст, умеют садиться и перекатываться
по команде.
 Эти два вида информации (кличка и возраст) и два вида поведения (сидеть и
перекатываться) будут включены в класс Dog, потому что они являются общими для
большинства собак:

'''

class Dog(): # Определяет класс с именем Dog
    ''''  Простая модель собаки '''

    def __init__(self, name, age):
        '''' Инициализирует атрибуты name & age.'''
        self.name = name
        self.age = age

    def sit(self):
        '''' Собака садится по команде '''
        print(f'{self.name} is now setting.')

    def roll_over(self):
        '''' Собака перекатывается по команде '''
        print(f'{self.name} rolled over! ')

''''

имена класса начинаются с символа верхнего регистра.
Круглые скобки в определении класса пусты, потому что класс создается с нуля.

Метод - это функция, являющаяся частью класса; отличается способом вызова. 

Атрибут - это переменная, выступающие в качестве параметра экземпляра класса; отличается способом обращения.

'''

''''
В классах могут использоваться два вида методов:
- метод __init__();
- метод имя_метода().
'''

''''
Метод __init__() — специальный метод, который автоматически выполняется при создании
каждого нового экземпляра данного класса.
 Имя метода начинается и заканчивается двумя символами подчеркивания; нарушение данной
нотации не вызовет данный метод.
 Метод __init__() определяет параметры, с которыми будет работать экземпляр (в
примере: self, name и age).

 Параметр self обязателен в определении метода, потому что при вызове метода
__init__() данному параметру будет передан аргумент автоматически, являющийся ссылкой на
экземпляр. Это позволит получить доступ к атрибутам и методам класса.
 Параметр self должен предшествовать всем остальным параметрам.
 В приведенном примере при создании экземпляра Dog значение self не передается. Мы
передаем лишь кличку и возраст в аргументах.
 Каждая из двух переменных в теле метода __init__() снабжена префиксом self, что дает
доступ к переменным в каждом экземпляре, созданном на основе класса.

 В приведенном примере конструкция self.name = name берет значение, хранящееся в
параметре name, и сохраняет его в атрибуте name, которая затем связывается с создаваемым
экземпляром. Аналогично с self.age = age.

'''

''''
Методы (аналоги функций) при определений должны иметь единственный параметр self.
 В приведенном примере определены два метода sit() и roll_over() с параметром self,
т.к. для из работы не требуется аргументов; они ограничиваются простым выводом сообщения
о том, что собака садится или перекатывается.
 Экземпляры, которые будут созданы позднее, смогут вызывать данные методы.
 
'''



''''
Создание экземпляра класса

Класс — это инструкция по созданию экземпляров данного класса.

В приведенном примере класс Dog — инструкция по созданию экземпляров, представляющих
конкретных собак

Создадим экземпляр, представляющий конкретную собаку:

'''

my_dog = Dog('Willie', 6) # Создаем экземпляр собакки с кличкой Willie и возрастом 6 лет

''''
В процессе обработки строки по созданию экземпляра вызывается метод __init__() класса Dog
с аргументами 'willie' и 6.
Метод __init__() создает экземпляр, представляющий конкретную собаку, и присваивает его
атрибутам name и age переданные значения.
В компьютере выделяется память для хранения экземпляра, представляющего конкретную
собаку; этот экземпляр сохраняется в переменной my_dog. 

Здесь нелишне вспомнить
соглашения по записи имен: обычно считается, что 
 --> имя, начинающееся с символа верхнего регистра (например, Dog), обозначает класс, 
 --> а имя, записанное в нижнем регистре (например, my_dog), обозначает отдельный экземпляр, созданный на базе класса.



Обращение к атрибутам
Для обращения к атрибутам экземпляра может использоваться «точечная» запись

Обратимся к значениям атрибутов экземпляра my_dog:

'''
print('    Обращение к атрибутам')
print(f'My Dog is name is {my_dog.name}.')
print(f'My dog is {my_dog.age} years old.')
# Этот синтаксис показывает, как Python обращается по имени к экземпляру класса для
#  получения значения среди его атрибутов.


print('    Вызов методов')
''''
Для вызова любых методов, определенных в классе применется «точечная» запись

Пример вызова методов, определенных в классе Dog:

'''
my_dog.sit() # вызываем метод sit() через имя my_dog, являющегося экземпляром класса
my_dog.roll_over() # вызываем метод roll_over() через my_dog, являющегося экземпляром класс

# Использование верхнего регистра первой буквы имени класса позволяет создавать производные
# имена экземпляров (нижний регистр)

''''
Создание нескольких экземпляров

На основе класса можно создать столько экземпляров, сколько вам потребуется.

Создадим второй экземпляр Dog с именем your_dog:
'''

print('    - Создание нескольких экземпляров -')
my_dog = Dog('Willie', 6)   # экземпляр с именем Willie
your_dog = Dog('lucy', 3)  # экземпляр с именем Lucy

# Каждый экземпляр обладает своим набором атрибутов
#    и способен выполнять действия из общего набора:

print(f" My dog's name is  {my_dog.name}.")
print(f" My dog is {my_dog.age} years old.")
my_dog.sit()

print(f"\nYour dogs name is {your_dog.name}.")
print(f"Your dod is {your_dog.age} years old.")
your_dog.sit()

мой_пес = Dog('Шарик', 150) # Создаю своего Шарика
print(f"\nМой добрый пёсик {мой_пес.name}")
print(f'Возраст песика {мой_пес.age} годиков')
мой_пес.sit()
мой_пес.roll_over()

# Можно создать сколько угодно экземпляров одного класса при условии, что эти экземпляры
# хранятся в переменных с разными именами или занимают разные позиции в списке либо
# словаре.
# В приведенном примере, если второй собаке будет назначено то же имя и возраст, Python все
# равно создаст отдельный экземпляр класса Dog.




''''
Работа с классами и экземплярами

Свойство классов описывать реальные ситуации обуславливает выполнение задач, связанных с
атрибутами данного экземпляра. Одной из таких задач является изменение атрибутов, связанных с
конкретным экземпляром.


Рассмотрим разработку класса на примере автомобиля.
Этот класс будет содержать информацию о типе машины и метод для вывода краткого описания:

'''

print('    - - Работа с классами и экземплярами')
print('    Рассмотрим разработку класса на примере автомобиля.')

class Car():
    """ Простая модель автомобиля. """
    def __init__(self, make, model, year): # определяется метод __init__() и его список параматров
        """Инициализирует атрибуты описания автомобиля."""
        self.make = make   # сохранение параметра make в атрибуте make класса Car
        self.model = model  # сохранение параметра model в атрибуте model класса Car
        self.year = year  # сохранение параметра year в атрибуте year класса Car

    def get_descriptive_name(self):  # метод, который объединяет год выпуска, фирму-производ, модель
        """Возвращает аккуратно отформатированное описание."""
        long_name = f"{self.year} {self.make} {self.model} "
        return long_name.title() # возвращаемое значение, как в функции


''''

Класс описывает некоторые параметры автомобиля.
Методы данного класса позволяют избавиться от необходимости выводить значение каждого
атрибута по отдельности.


Создадим экземпляр класса Car, которую сохраним в переменной my_new_car:
'''
my_new_car = Car('audi', 'A4', 2019)

''''
Вызовем метод get_descriptive_name(), которое выведет сведения о параметрах автомобиля,
хранящихся в экземпляре my_new_car:
'''
print('   Вызовем метод get_descriptive_name(), которое выведет сведения о параметрах автомобиля,')

print(my_new_car.get_descriptive_name())

моя_тачка = Car('Лада', 'Гранта', 1945)
print(моя_тачка.get_descriptive_name())
# В данном примере мы заставили метод работать с атрибутами экземпляра.
# Далее добавим атрибут, изменяющийся со временем, — в нем будет храниться пробег машины в
# километрах.




