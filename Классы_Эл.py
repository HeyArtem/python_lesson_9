print()
print()
print('    - Классы')




''''

Эльдар

Классы в объектно-ориентированном программировании призваны описывать реально существующие
предметы и ситуации для представления их в виде объектов, обладающих как общим поведением, так и
уникальными особенностями.
Создание объекта на основе класса называется созданием экземпляра, т.е. данный объект является
экземпляром класса.
Классы упрощают реализацию серьезных проектов.
'''''

print()
print()
print('    - Создание и использование класса')


'''
Создадим простой класс Dog, представляющий собаку — не какую-то конкретную, а собаку
вообще.
 Перечислим знания о собаках: есть кличка и возраст, умеют садиться и перекатываться
по команде.
 Эти два вида информации (кличка и возраст) и два вида поведения (сидеть и
перекатываться) будут включены в класс Dog, потому что они являются общими для
большинства собак:

'''

print()
print()
print('    - Пример создания класса')



class Dog(): # Определяет класс с именем Dog
    ''''  Простая модель собаки '''

    def __init__(self, name, age):
        '''' Инициализирует атрибуты name & age.'''
        self.name = name
        self.age = age

    def sit(self):
        '''' Собака садится по команде '''
        print(f'{self.name} is now setting.')

    def roll_over(self):
        '''' Собака перекатывается по команде '''
        print(f'{self.name} rolled over! ')




"""
По общепринятым соглашениям имена класса начинаются с символа верхнего регистра.
Круглые скобки в определении класса пусты, потому что класс создается с нуля.
Строка документации с кратким описанием класса аналогична нотации, применяемой для
описания функций.

"""


print()
print()
print('    - Методы')


''''

Метод - это функция, являющаяся частью класса; отличается способом вызова. 

Атрибут - это переменная, выступающие в качестве параметра экземпляра класса; отличается способом обращения.

'''


''''
В классах могут использоваться два вида методов:
- метод __init__();
- метод имя_метода().
'''

''''
Метод __init__() — специальный метод, который автоматически выполняется при создании
каждого нового экземпляра данного класса.
 Имя метода начинается и заканчивается двумя символами подчеркивания; нарушение данной
нотации не вызовет данный метод.
 Метод __init__() определяет параметры, с которыми будет работать экземпляр (в
примере: self, name и age).

 Параметр self обязателен в определении метода, потому что при вызове метода
__init__() данному параметру будет передан аргумент автоматически, являющийся ссылкой на
экземпляр. Это позволит получить доступ к атрибутам и методам класса.
 Параметр self должен предшествовать всем остальным параметрам.
 В приведенном примере при создании экземпляра Dog значение self не передается. Мы
передаем лишь кличку и возраст в аргументах.
 Каждая из двух переменных в теле метода __init__() снабжена префиксом self, что дает
доступ к переменным в каждом экземпляре, созданном на основе класса.

 В приведенном примере конструкция self.name = name берет значение, хранящееся в
параметре name, и сохраняет его в атрибуте name, которая затем связывается с создаваемым
экземпляром. Аналогично с self.age = age.

'''

''''
Методы (аналоги функций) при определений должны иметь единственный параметр self.
 В приведенном примере определены два метода sit() и roll_over() с параметром self,
т.к. для из работы не требуется аргументов; они ограничиваются простым выводом сообщения
о том, что собака садится или перекатывается.
 Экземпляры, которые будут созданы позднее, смогут вызывать данные методы.
 
'''

print()
print()
print('    - Создание экземпляра класса')

''''
Создание экземпляра класса

Класс — это инструкция по созданию экземпляров данного класса.

В приведенном примере класс Dog — инструкция по созданию экземпляров, представляющих
конкретных собак

Создадим экземпляр, представляющий конкретную собаку:

'''

my_dog = Dog('Willie', 6) # Создаем экземпляр собакки с кличкой Willie и возрастом 6 лет

''''
В процессе обработки строки по созданию экземпляра вызывается метод __init__() класса Dog
с аргументами 'willie' и 6.
Метод __init__() создает экземпляр, представляющий конкретную собаку, и присваивает его
атрибутам name и age переданные значения.
В компьютере выделяется память для хранения экземпляра, представляющего конкретную
собаку; этот экземпляр сохраняется в переменной my_dog. 

Здесь нелишне вспомнить
соглашения по записи имен: обычно считается, что 
 --> имя, начинающееся с символа верхнего регистра (например, Dog), обозначает класс, 
 --> а имя, записанное в нижнем регистре (например, my_dog), обозначает отдельный экземпляр, созданный на базе класса.



Обращение к атрибутам
Для обращения к атрибутам экземпляра может использоваться «точечная» запись

Обратимся к значениям атрибутов экземпляра my_dog:

'''



print()
print()
print('    - Обращение к атрибутам')



print(f'My Dog is name is {my_dog.name}.')
print(f'My dog is {my_dog.age} years old.')
# Этот синтаксис показывает, как Python обращается по имени к экземпляру класса для
#  получения значения среди его атрибутов.


print()
print()
print('    - Вызов методов')

''''
Для вызова любых методов, определенных в классе применется «точечная» запись

Пример вызова методов, определенных в классе Dog:

'''
my_dog.sit() # вызываем метод sit() через имя my_dog, являющегося экземпляром класса
my_dog.roll_over() # вызываем метод roll_over() через my_dog, являющегося экземпляром класс

# Использование верхнего регистра первой буквы имени класса позволяет создавать производные
# имена экземпляров (нижний регистр)

''''
Создание нескольких экземпляров

На основе класса можно создать столько экземпляров, сколько вам потребуется.

Создадим второй экземпляр Dog с именем your_dog:
'''



print()
print()
print('    - Создание нескольких экземпляров')


my_dog = Dog('Willie', 6)   # экземпляр с именем Willie
your_dog = Dog('lucy', 3)  # экземпляр с именем Lucy

# Каждый экземпляр обладает своим набором атрибутов
#    и способен выполнять действия из общего набора:

print(f" My dog's name is  {my_dog.name}.")
print(f" My dog is {my_dog.age} years old.")
my_dog.sit()

print(f"\nYour dogs name is {your_dog.name}.")
print(f"Your dod is {your_dog.age} years old.")
your_dog.sit()

мой_пес = Dog('Шарик', 150) # Создаю своего Шарика
print(f"\nМой добрый пёсик {мой_пес.name}")
print(f'Возраст песика {мой_пес.age} годиков')
мой_пес.sit()
мой_пес.roll_over()

# Можно создать сколько угодно экземпляров одного класса при условии, что эти экземпляры
# хранятся в переменных с разными именами или занимают разные позиции в списке либо
# словаре.
# В приведенном примере, если второй собаке будет назначено то же имя и возраст, Python все
# равно создаст отдельный экземпляр класса Dog.




''''
Работа с классами и экземплярами

Свойство классов описывать реальные ситуации обуславливает выполнение задач, связанных с
атрибутами данного экземпляра. Одной из таких задач является изменение атрибутов, связанных с
конкретным экземпляром.


Рассмотрим разработку класса на примере автомобиля.
Этот класс будет содержать информацию о типе машины и метод для вывода краткого описания:

'''



print()
print()
print('    - Работа с классами и экземплярами')



class Car():
    """ Простая модель автомобиля. """
    def __init__(self, make, model, year): # определяется метод __init__() и его список параматров
        """Инициализирует атрибуты описания автомобиля."""
        self.make = make   # сохранение параметра make в атрибуте make класса Car
        self.model = model  # сохранение параметра model в атрибуте model класса Car
        self.year = year  # сохранение параметра year в атрибуте year класса Car

    def get_descriptive_name(self):  # метод, который объединяет год выпуска, фирму-производ, модель
        """Возвращает аккуратно отформатированное описание."""
        long_name = f"{self.year} {self.make} {self.model} "
        return long_name.title() # возвращаемое значение, как в функции


''''

Класс описывает некоторые параметры автомобиля.
Методы данного класса позволяют избавиться от необходимости выводить значение каждого
атрибута по отдельности.


Создадим экземпляр класса Car, которую сохраним в переменной my_new_car:
'''
my_new_car = Car('audi', 'A4', 2019)

''''
Вызовем метод get_descriptive_name(), которое выведет сведения о параметрах автомобиля,
хранящихся в экземпляре my_new_car:
'''
print('   Вызовем метод get_descriptive_name(), которое выведет сведения о параметрах автомобиля,')

print(my_new_car.get_descriptive_name())

моя_тачка = Car('Лада', 'Гранта', 1945)
print(моя_тачка.get_descriptive_name())
# В данном примере мы заставили метод работать с атрибутами экземпляра.
# Далее добавим атрибут, изменяющийся со временем, — в нем будет храниться пробег машины в
# километрах.



print()
print()
print('    - Назначение атрибуту значения по умолчанию')


''''
Каждый атрибут класса должен иметь исходное значение, 
даже если оно равно 0 или пустой строке.

В некоторых случаях (например, при задании значений по умолчанию) это исходное значение
есть смысл задавать в теле метода __init__(); в этом случае при создании объекта не
обязательно передавать параметр для этого атрибута.


Добавим атрибут с именем odometer_reading, исходное значение которого всегда равно 0.
Также в класс будет включен метод read_odometer() для чтения текущих показаний одометра:

'''
class Тачки():
    '''' Простая модель автомобиля'''

    def __init__(self, брэнд, модель, год):
        self.брэнд = брэнд
        self.модель = модель
        self.год = год
        self.одометр = 0 # Добавили атрибут, он будет всегда 0 при создании обьектов

    def описательное_имя(self):
        '''' Возвращает аккуратно отформатрованное описание '''

        полное_имя = f"{self.год} {self.брэнд} {self.модель}"
        return полное_имя

    def чтение_одометра(self): # Этот метод упрощает чтение пробега машины.
        '''' Выводит пробег машины в километрах. '''
        print(f" Этот автомобиль имеет {self.одометр} км. пробега ")

# Создадим новый объект
новыйОбъект_мояТачка = Тачки('Москвич', 412, 1975)

'''

Вызовим 2 метода:
1) сведения о параметрах автомобиля, хранящихся в экземпляре my_new_car;
2) сведения о значении одометра, хранящегося в экземпляре my_new_car.

'''
print(новыйОбъект_мояТачка.описательное_имя())
новыйОбъект_мояТачка.чтение_одометра()

''''
Поскольку в методе __init__ не определен параметр атрибута пробега, то при создании
объекта он всегда будет равен 0.
Но, при продаже машин одометр редко показывает ровно 0, поэтому нам понадобится способ
изменения значения этого атрибута.

'''


print()
print()
print('    - Изменение значений атрибутов')



''''
Значение атрибута можно изменить одним из трех способов:
изменить его прямо в экземпляре (прямое изменение);
задать значение при помощи метода;
изменить его с приращением при помощи метода.

'''


print(' - Прямое изменение значения атрибута')
''''
Самым простым способом изменения значения атрибута является обращение к нему через экземпляр.
Но, такой способ не рекомендуется!

В следующем примере на одометре напрямую выставляется значение 23:


'''

новыйОбъект_мояТачка.одометр = 23
''''
Здесь была использована «точечная» запись для обращения к атрибуту self.одометр для
присваивания ему значения.

Порядок: берем экземпляр новыйОбъект_мояТачка, находим связанный 
с ним атрибут одометр и
задаем значение атрибута равным 23.

Проверим значение атрибута odometer_reading в экземапляре класса:

'''
новыйОбъект_мояТачка.чтение_одометра()

print(' - Изменение значения атрибута с использованием метода')
''''
Наиболее рационально использовать вспомогательный метод, который обновляет значение атрибута.
Данный метод должен получить в качестве аргумента требуемое значение, и имея доступ к целевому
атрибуту экземпляра, берет обновление атрибута на себя.

В следующем примере в класс включается метод update_odometer() для обновления показаний
одометра:
'''
class Тачки():
    '''' Простая модель автомобиля'''
    def __init__(self, брэнд, модель, год):
        self.брэнд = брэнд
        self.модель = модель
        self.год = год
        self.одометр = 0 # Добавили атрибут, он будет всегда 0 при создании обьектов

    def описательное_имя(self):
        '''' Возвращает аккуратно отформатрованное описание '''
        полное_имя = f"{self.год} {self.брэнд} {self.модель}"
        return полное_имя

    def чтение_одометра(self): # Этот метод упрощает чтение пробега машины.
        '''' Выводит пробег машины в километрах. '''
        print(f" Этот автомобиль имеет {self.одометр} км. пробега ")


    def update_odometr(self, mileage): # добавили метод; получает значение пробега и сохр
        """Устанавливает заданное значение на одометре."""
        self.одометр = mileage
''''
Вызовем метод update_odometer() и передадим ему значение -30 в аргументе (соответствующем
параметру kilometers в определении метода):

'''
новыйОбъект_мояТачка = Тачки('audi', 'a4', 2019)
новыйОбъект_мояТачка.update_odometr(-30)
новыйОбъект_мояТачка.чтение_одометра()

''''
Расширим метод update_odometer() так, чтобы при каждом его вызове проводилась проверка на
предмет сброса показаний одометра:
'''
class Тачки():
    '''' Простая модель автомобиля'''
    def __init__(self, брэнд, модель, год):
        self.брэнд = брэнд
        self.модель = модель
        self.год = год
        self.одометр = 0 # Добавили атрибут, он будет всегда 0 при создании обьектов

    def описательное_имя(self):
        '''' Возвращает аккуратно отформатрованное описание '''
        полное_имя = f"{self.год} {self.брэнд} {self.модель}"
        return полное_имя

    def чтение_одометра(self): # Этот метод упрощает чтение пробега машины.
        '''' Выводит пробег машины в километрах. '''
        print(f" Этот автомобиль имеет {self.одометр} км. пробега ")

    def update_odometer(self, mileage):
        """
        Устанавливает заданное значение на одометре.
        При попытке обратной подкрутки изменение отклоняется.
        """
        if mileage >= self.одометр:  # добавили условие; проверяет новое значение п
            self.одометр = mileage
        else:
            print("Одометр не откатишь назад !!!")

''''
Если новое значение mileage больше или равно текущему, то показания одометра можно
обновить новым значением.
Если новое значение меньше текущего, то получим предупреждение о недопустимости обратной
подкрутки.

'''
print('проверка')
новыйОбъект_мояТачка = Тачки('audi', 'a8', 2020)
новыйОбъект_мояТачка.update_odometer(-30)
новыйОбъект_мояТачка.чтение_одометра()
print('проверка 2 ')
новыйОбъект_мояТачка = Тачки('audi', 'a8', 2020)
новыйОбъект_мояТачка.update_odometer(600)
новыйОбъект_мояТачка.чтение_одометра()


print()
print(' - Изменение значения атрибута с приращением')
''''
Для изменения атрибута на заданное значение без его полного обновления также рекомендуется
применять метод.

Например, после покупки автомобиля пробег увеличился на 100 километров.
Следующий метод получает величину приращения и прибавляет ее к текущим показаниям
одометра:


'''
class Тачки():
    '''' Простая модель автомобиля'''
    def __init__(self, брэнд, модель, год):
        self.брэнд = брэнд
        self.модель = модель
        self.год = год
        self.одометр = 0 # Добавили атрибут, он будет всегда 0 при создании обьектов

    def описательное_имя(self):
        '''' Возвращает аккуратно отформатрованное описание '''
        полное_имя = f"{self.год} {self.брэнд} {self.модель}"
        return полное_имя

    def чтение_одометра(self): # Этот метод упрощает чтение пробега машины.
        '''' Выводит пробег машины в километрах. '''
        print(f" Этот автомобиль имеет {self.одометр} км. пробега ")

    def update_odometer(self, mileage):
        """
        Устанавливает заданное значение на одометре.
        При попытке обратной подкрутки изменение отклоняется.
        """
        if mileage >= self.одометр:  # добавили условие; проверяет новое значение п
            self.одометр = mileage
        else:
            print("Одометр не откатишь назад !!!")
    def increment_odometer(self, kilometers): # добавили метод; получает расстояние в кило
        """Увеличивает показания одометра с заданным приращением."""
        if kilometers >= 0:
            self.одометр += kilometers
        else:
            print("Одометр не откатишь назад никак!!!")
# Создадим экземпляр my_used_car класса Тачки:
my_used_car = Тачки('subaru', 'outback', 2015)
print(my_used_car.описательное_имя()) # пока все четко

''''
Инициализируем показания его одометра значением 23 500; для этого вызывается метод
update_odometer(), которому передается значение 23 500:
'''
my_used_car.update_odometer(23_500)
my_used_car.чтение_одометра() # Контрольная проверка, пока все ок
''''
Вызовем метод increment_odometer(), которому передадим значение 300, чтобы увеличить
показания одометра на 100 километров, пройденные с момента покупки:

'''
print('Увидим, как пробег прибавился:')
my_used_car.increment_odometer(300)
my_used_car.чтение_одометра()

''''
ПРИМЕЧАНИЕ. Подобные методы управляют обновлением внутренних значений экземпляров (таких, как
показания одометра), однако любой пользователь, имеющий доступ к программному коду, сможет
напрямую задать атрибуту любое значение. Эффективная схема безопасности должна уделять особое
внимание таким подробностям, не ограничиваясь простейшими проверками.

В качестве дополнительного упражнения необходимо усовершенствовать метод
increment_odometer(), чтобы он отклонял отрицательные приращения; тем самым будет
предотвращена обратная подкрутка одометра.

'''

print()
print('    Моя попытка сделать защиту от уменьшение пробега ')
class Тачки():
    '''' Простая модель автомобиля'''
    def __init__(self, брэнд, модель, год):
        self.брэнд = брэнд
        self.модель = модель
        self.год = год
        self.одометр = 0 # Добавили атрибут, он будет всегда 0 при создании обьектов

    def описательное_имя(self):
        '''' Возвращает аккуратно отформатрованное описание '''
        полное_имя = f"{self.год} {self.брэнд} {self.модель}"
        return полное_имя

    def чтение_одометра(self): # Этот метод упрощает чтение пробега машины.
        '''' Выводит пробег машины в километрах. '''
        print(f" Этот автомобиль имеет {self.одометр} км. пробега ")

    def update_odometer(self, mileage):
        """
        Устанавливает заданное значение на одометре.
        При попытке обратной подкрутки изменение отклоняется.
        """
        if mileage >= self.одометр:  # добавили условие; проверяет новое значение п
            self.одометр = mileage
        else:
            print("Одометр не откатишь назад !!!")
    def increment_odometer(self, kilometers): # добавили метод; получает расстояние в кило
        """Увеличивает показания одометра с заданным приращением."""
        if kilometers >= 0:
            self.одометр += kilometers
        else:
            print("Одометр не откатишь назад никак!!!")
# Создадим экземпляр my_used_car класса Тачки:
my_used_car = Тачки('лада', 'восьмерка', 2000)
print(my_used_car.описательное_имя()) # пока все четко
my_used_car.update_odometer(200_000) #задали ладе пробег 200 т.км.
my_used_car.чтение_одометра() # Контрольная распечатка


my_used_car.increment_odometer(-100000) # пробуем отмотать 100 т.км.
my_used_car.чтение_одометра() # и увидим, что не отматать




print()
print()
print('    - Наследование')



''''
Преимущества работы с классами заключается в том, что работа над новым классом не обязана
начинаться с нуля. Если класс, который вы пишете, представляет собой специализированную версию
ранее написанного класса, вы можете воспользоваться наследованием. Один класс, наследующий от
другого, автоматически получает все атрибуты и методы первого класса.
Исходный класс называется родителем, а новый класс — потомком. Класс-потомок наследует атрибуты
и методы родителя, но при этом также может определять собственные атрибуты и методы.

'''
print('   ** Метод init() класса-потомка')

''''
При написании нового класса на базе существующего класса часто приходится вызывать метод
__init__() класса-родителя.
При этом происходит инициализация любых атрибутов, определенных в методе __init__()
родителя, и эти атрибуты становятся доступными для класса-потомка.

Рассмотрим пример класса, описывающий модель электромобиля.
Класс электромобиля назовем ElectricCar, но так как электромобиль представляет собой
специализированную разновидность автомобиля, то данный класс можно создать на базе класса
Car, написанного ранее.
 В этом случае достаточно добавить в него код атрибутов и поведения, относящегося
только к электромобилям.

Повторим для наглядности код класса Тачки, т.к. определение класса-родителя должно
предшествовать определению класса-потомка в файле.

'''


class Тачки():
    '''' Простая модель автомобиля'''
    def __init__(self, брэнд, модель, год):
        self.брэнд = брэнд
        self.модель = модель
        self.год = год
        self.одометр = 0 # Добавили атрибут, он будет всегда 0 при создании обьектов

    def описательное_имя(self):
        '''' Возвращает аккуратно отформатрованное описание '''
        полное_имя = f"{self.год} {self.брэнд} {self.модель}"
        return полное_имя

    def чтение_одометра(self): # Этот метод упрощает чтение пробега машины.
        '''' Выводит пробег машины в километрах. '''
        print(f" Этот автомобиль имеет {self.одометр} км. пробега ")

    def update_odometer(self, mileage):
        """
        Устанавливает заданное значение на одометре.
        При попытке обратной подкрутки изменение отклоняется.
        """
        if mileage >= self.одометр:  # добавили условие; проверяет новое значение п
            self.одометр = mileage
        else:
            print("Одометр не откатишь назад !!!")
    def increment_odometer(self, kilometers): # добавили метод; получает расстояние в кило
        """Увеличивает показания одометра с заданным приращением."""
        if kilometers >= 0:
            self.одометр += kilometers
        else:
            print("Одометр не откатишь назад никак!!!")

''''

Начнем с создания простой версии класса ElectricCar, который делает все, что делает
класс Car.
В определении потомка имя класса-родителя заключается в круглые скобки.

'''
class ElectricCar(Тачки): # определяется класс-потомок ElectricCar; имя класса-родителя заклю
    """Представляет аспекты машины, специфические для электромобилей."""
    def __init__(self, брэнд, модель, год):  # получает информацию, необходимую для создания
        """инициализирует атрибуты класса-родителя."""
        super().__init__(брэнд, модель, год)


''''
Функция super() — специальная функция, которая позволяет вызвать метод родительского
класса.
Имя super происходит из распространенной терминологии: класс-родитель называется
суперклассом, а класс-потомок — подклассом.

В приведенном примере с использованием функции super() вызвается метод __init__()
класса Тачки, в результате чего экземпляр ElectricCar получает доступ ко всем атрибутам
класса-родителя.

Создадим электромобиль с такой же информацией, которая передается при создании
обычного экземпляра Тачки; создадим экземпляр класса ElectricCar и сохраняем его в
my_tesla.
 Следующая первая строка вызывает метод __init__(), определенный в ElectricCar,
который, в свою очередь, приказывает Python вызвать метод __init__(), определенный в
классе-родителе Тачки. При вызове передаются аргументы 'tesla', 'model s' и 2019.


'''

my_tesla = ElectricCar('tesla', 'model s', 2019)
print(my_tesla.описательное_имя())

''''
Класс ElectricCar еще не содержит никаких специфических для электромобилей атрибутов
или методов, кроме __init__().
Убедившись, что экземпляр ElectricCar работает так же, как экземпляр Car; можно
переходить к определению атрибутов и методов, специфических для модели электромобиля.

'''


print()
print()
print('    - Определение атрибутов и методов класса-потомка')


''''
Чтобы класс-потомок отличался от класса-родителя следует добавить новые атрибуты и методы.

Добавим атрибут, специфический для электромобилей (например, мощность аккумуляторa) и
метод для вывода информации об этом атрибуте:

'''
class ElectricCar(Тачки):
    """Представляет аспекты машины, специфические для электромобилей."""
    def __init__(self, брэнд, модель, год):
        """
         Инициализирует атрибуты класса-родителя.
         Затем инициализирует атрибуты, специфические для электромобиля.
         """

        super().__init__(брэнд, модель, год)
        self.объем_батареи = 75 # добавлен атрибут; присвоили исходное значение
    def describe_battery(self):
        """Выводит информацию о мощности аккумулятора."""
        print(f"Этот автомобиль имеет батарею {self.объем_батареи}-kWh.")

print(' Проверим работу класса с батареей:')

my_tesla = ElectricCar('tesla', 'models', 2019) # создали экземпляр
print(my_tesla.описательное_имя()) # описание автомобиля
my_tesla.describe_battery() # описание аккумулятора
''''
Атрибут объем_батареи будет присутствовать во всех экземплярах, созданных на основе
класса ElectricCar (но не во всяком экземпляре Car).

Метод describe_battery() выводит описание, которое явно относится только к
электромобилям.

Возможности специализации класса-потомка неограничены. Вы можете добавить сколько
угодно атрибутов и методов.
 В данном примере атрибуты или методы, которые могут принадлежать любой машине (а не
только электромобилю), должны добавляться в класс Car вместо ElectricCar. Тогда эта
информация будет доступна всем пользователям класса Car, а класс ElectricCar будет
содержать только код информации и поведения, специфических для электромобилей.

'''




print()
print()
print('    - Переопределение методов класса-родителя')


""""
Любой метод родительского класса, который в моделируемой ситуации делает не то, что нужно, можно
переопределить. Для этого в классе-потомке определяется метод с тем же именем, что и у метода
класса-родителя. Python игнорирует метод родителя и обращает внимание только на метод,
определенный в потомке.

Допустим, в классе Car имеется метод fill_gas_tank(). Для электромобилей заправка
бензином бессмысленна, поэтому этот метод логично переопределить. Например, это можно
сделать так:

"""

class ElectricCar(Тачки):
    """Представляет аспекты машины, специфические для электромобилей."""
    def __init__(self, брэнд, модель, год):
        """
         Инициализирует атрибуты класса-родителя.
         Затем инициализирует атрибуты, специфические для электромобиля.
         """

        super().__init__(брэнд, модель, год)
        self.объем_батареи = 75 # добавлен атрибут; присвоили исходное значение
    def describe_battery(self):
        """Выводит информацию о мощности аккумулятора."""
        print(f"Этот автомобиль имеет батарею {self.объем_батареи}-kWh.")

    def fill_gas_tank(self):  # условно игнорируется метод fill_gas_tank() класса Car;
        """"У Электромобилей нет бензобака """
        print("Этой машиен не нужен бензобак")

""""
С применением наследования потомок сохраняет те аспекты родителя, которые вам нужны, и
переопределяет все ненужное.

"""


print()
print()
print('    - Экземпляры как атрибуты')


""""
При моделировании явлений реального мира в программах классы нередко дополняются все большим
количеством подробностей. Списки атрибутов и методов растут, и через какое-то время файлы
становятся длинными и громоздкими. В такой ситуации часть одного класса нередко можно записать в
виде отдельного класса. Большой код разбивается на меньшие классы, которые работают во
взаимодействии друг с другом.

Например, при дальнейшей доработке класса ElectricCar может оказаться, что в нем
появилось слишком много атрибутов и методов, относящихся к аккумулятору.
 В этом случае можно переместить все эти атрибуты и методы в отдельный класс с именем
Battery:

"""
class Battery(): # Определяется новый класс с именем Battery, который не наследует ни один
    """Простая модель аккумулятора электромобиля."""

    def __init__(self, объем_батареи = 75): # перемещен из класса ElectricCar; получает параме
        """Инициализирует атрибуты аккумулятора."""
        self.объем_батареи = объем_батареи


    def describe_battery(self): # метод перемещен из класса ElectricCar.
        """Выводит информацию о мощности аккумулятора."""
        print(f" Этот автомобиль имеет батарею {self.объем_батареи} -kWh")

# Затем экземпляр Battery становится атрибутом класса ElectricCar:

class ElectricCar(Тачки):
    """Представляет аспекты машины, специфические для электромобилей."""
    def __init__(self, брэнд, модель, год):
        """
         Инициализирует атрибуты класса-родителя.
         Затем инициализирует атрибуты, специфические для электромобиля.
         """

        super().__init__(брэнд, модель, год)
        self.battery = Battery()  # добавлен атрибут, которому присвоен экземпляр класса Bat

""""
В последней строке создается новый экземпляр Battery (со значением battery_size по
умолчанию, равным 75, потому что значение не задано) и сохранить его в атрибуте
self.battery. Это будет происходить при каждом вызове __init__(); теперь любой экземпляр
ElectricCar будет иметь автоматически создаваемый экземпляр Battery.

Проверим работу обновленного класса:

"""

my_tesla = ElectricCar('tesla', 'model s', 2019)  # создали экземпляр
print(my_tesla.описательное_имя())          # описание автомобиля
my_tesla.battery.describe_battery()         # описание аккумулятора !!!

""""
В последней строке происходит обращение к экземпляру my_tesla, где переходим к атрибуту
battery и вызываем метод describe_battery(), связанный с экземпляром Battery (в классе
которого определен метод describe_battery())!

Результат выглядит так же, как и в предыдущей версии.
На первый взгляд новый вариант требует большой дополнительной работы, но теперь
аккумулятор можно моделировать с любой степенью детализации без загромождения класса
ElectricCar.
 
 
 Добавим в класс Battery еще один метод, который выводит запас хода на основании
мощности аккумулятора:

"""
class Battery(): # Определяется новый класс с именем Battery, который не наследует ни один
    """Простая модель аккумулятора электромобиля."""

    def __init__(self, объем_батареи = 75): # перемещен из класса ElectricCar; получает параме
        """Инициализирует атрибуты аккумулятора."""
        self.объем_батареи = объем_батареи


    def describe_battery(self): # метод перемещен из класса ElectricCar.
        """Выводит информацию о мощности аккумулятора."""
        print(f" Этот автомобиль имеет батарею {self.объем_батареи} -kWh")

    def get_range(self):  # добавили новый метод; проводит анализ:
        """Выводит приблизительный запас хода для аккумулятора."""

        if self.объем_батареи == 75: # если мощность равна 75 kWh, то запас хода равен 260 миль
            range = 260
        elif self.объем_батареи == 100:  # иначе; при мощности 100 kWh запас хода равен 315 миль
            range = 315

        print(f"Этот автомобиль может проехать {range} миль на полной зарядке.")

my_tesla = ElectricCar('tesla', 'model s', 2019)
print(my_tesla.описательное_имя())
my_tesla.battery.describe_battery()
my_tesla.battery.get_range()

""""
Комментарий.
Для вызова метода, являющийся частью класса, экземпляр которого был определен в другом
классе в качестве атрибута, следует обращаться через имя данного атрибута!

"""


print()
print()
print('    - Моделирование объектов реального мира')

""""
При моделировании объектов реального мира необходимо представлять уровень прменимости
разрабатываемых классов. Исходя из этого может возникать вопрос: экземпляры каких классов
будут выступать в качестве атрибутов для других классов.
 Данные вопросы позволяют мыслить на более высоком логическом уровне, не ограничиваясь
уровнем синтаксиса. Основной целью начинает выступать правильное описание реального мира
в коде.
 Достигнув этого уровня вопросов, вы поймете, что однозначно правильного или
неправильного подхода к моделированию реальных ситуаций часто не существует. Некоторые
методы эффективнее других, но для того, чтобы найти наиболее эффективную реализацию,
необходим практический опыт. На пути к написанию точного, эффективного кода все
программисты проходят процесс переписывания своих классов для разных решений.

"""













print()
print()
print('    - Импортирование классов')
""""
Добавление новой функциональности в классы может формировать слишком длинные програмы. По
аналогии с функциями классы можно хранить в модулях и импортировать нужные классы в основную
программу.

"""
print('    *Импортирование одного класса')

''''
Создадим модуль, содержащий только класс (на примере класса Car). Сохраним его в
модуле с именем car.py.

Порядок:
1. http://localhost:8888/tree (http://localhost:8888/tree)
2. New -> Text File
3. Помещаем код
4. File -> Rename -> [имя модуля].py
5. Save

Ниже приведен файл car.py с кодом класса Car:

'''



# Далее импортруем класс Car и создадим экземпляр этого класса:

del Car
from Car import Car # оТкрываем модуль Car и импортируем модуль Car

my_new_car = Car('audi', 'a4', 2019)
print(my_new_car.get_descriptive_name())

my_new_car.odometer_reading = 23
my_new_car.read_odometer()

""""
Перемещая класс в модуль и импортируя этот модуль мы получаем ту же функциональность,
но основной файл программы при этом остается чистым и удобочитаемым.
 Когда большая часть кода храниться в отдельных файлах можно сосредоточиться на
высокоуровневой логике основной программы.

"""


print()
print()
print('    *Хранение нескольких классов в модуле')

""""
В одном модуле можно хранить сколько угодно классов, хотя все эти классы должны быть каким-то
образом связаны друг с другом.

Классы Battery и ElectricCar могут использоваться для представления электромобилей,
поэтому добавим их в модуль car.py:

Я перехожу на car.py

# добавить в конец файла car.py

"""

# Создадим новую программу, куда импортируем класс ElectricCar и создать новый экземпляр
# электромобиля:

from Car import ElectricCar

my_tesla_2 = ElectricCar('tesla', 'model X', 2020) # создали экземпляр
print(my_tesla_2.get_descriptive_name())           # вывели на печать характеристики машины
my_tesla_2.battery.describe_battery()               # вывели на печать мощность аккумулятора
my_tesla_2.battery.get_range()                      # вывели на печать запас хода


print()
print()
print('    *Импортирование нескольких классов из модуля')

""""
Чтобы импортировать несколько классов из модуля необходимо разделить их имена запятыми. После
того как необходимые классы будут импортированы можно создать любое число экземпляров каждого
класса.

Создадим по одному экземпляру обычного автомобиля и электромобиля:

"""

from Car import Car, ElectricCar # из одного модуля импортировали разные классы

my_beetle = Car('volkswagen', 'beetle', 2019) # Экземпляр обычного автомобиля
print(my_beetle.get_descriptive_name())

my_tesla = ElectricCar('tesla', 'roadster', 2019)   # экземпляр электромобиля
print(my_tesla.get_descriptive_name())



print()
print()
print('    *Импортирование всего модуля')
""""
Существует возможность импортировать весь модуль, а потом обращаться к нужным классам с
использованием точечной записи. Преимуществом данного подхода явялется то, что в
программе не будет конфликтов с именами, т.к. каждый вызов, создающий экземпляр класса,
включает имя модуля (кроме случаев создания переменной/объекта, имя которой совпадает с
именем импортированного модуля)

Создадим по одному экземпляру обычного автомобиля и электромобиля (из одного модуля, но
без импортирования отдельных классов):

"""

import Car

my_beetle = Car.Car('volkswagen', 'beetle', 2019)
print(my_beetle.get_descriptive_name())

my_tesla = Car.ElectricCar('tesla', 'roadster', 2019)
print(my_tesla.get_descriptive_name())

""""
Результат аналогичен при импортировании нескольких классов из модуля, но обращение
выполняется с использованием синтаксиса: имя_модуля.имя_класса.

"""

print()
print()
print('    *Импортирование всех классов из модуля')
""""
Для импортирования всех классов из модуля используется следующий синтаксис:

from имя_модуля import *

В приведенном примере вызов будет следующим:

"""

from Car import *

""""
Создадим по одному экземпляру обычного автомобиля и электромобиля (из одного модуля
импортировали все существующие классы):

"""
import Car
my_lada = Car.Car('Lada', 'Samara', 1987)
print(my_lada.get_descriptive_name())

my_zetta = Car.ElectricCar('Lada', 'Zetta', 2021)
print(my_zetta.get_descriptive_name())

""""
ПРИМЕЧАНИЕ.
 Использовать этот способ не рекомендуется по 2 причинам:
1. В программе могут появится избыточные классы;
2. Возможны конфликты с именами в программе.
 Однако данный подход можно встретить в коде других разработчиков.

РЕКОМЕНДАЦИЯ.
Если нужно импортировать большое количество классов из модуля, лучше импортировать
весь модуль и воспользоваться синтаксисом имя_модуля.имя_класса.
 В данном случае не видно перечня всех используемых классов в начале файла, но теперь
видно, где модуль используется в программе. Также предотвращаются потенциальные конфликты
имен, которые могут возникнуть при импортировании каждого класса в модуле.

"""

print()
print()
print('    - Импортирование модуля в модуль')

""""
Чтобы избежать чрезмерного разрастания одного файла либо хранения несвязанных классов в одном
модуле классы приходится распределять по нескольким модулям. Но при хранении классов в нескольких
модулях один класс из одного модуля может зависеть от класса из другого модуля. В этом случае
необходимый класс можно импортировать в первый модуль.


Допустим, класс Car хранится в одном модуле, а классы ElectricCar и Battery — в другом.
Мы создадим новый модуль с именем electric_car.py и скопируем в него только классы
Battery и ElectricCar:

"""

""""
Я создал Car_2.py  и electric_car_py

Теперь можно импортировать классы из каждого модуля по отдельности и создавать ту
разновидность машины, которая нужна:
"""
from Car_2 import Car #Импортируем из родительского класса
from electric_car import ElectricCar #Импортируем из класса потомка, который включает класс..import

my_lada_2 = Car('Lada_2', 'Samara_2', 1987)
print(my_lada_2.get_descriptive_name())

my_zetta_2 = ElectricCar('Lada_2', 'Zetta_2', 2021)
print(my_zetta_2.get_descriptive_name())



print()
print()
print('    - Использование псевдонимов')

""""
По аналогии с модулями, содержащими функции, псевдонимы весьма полезны при использовании и при
импортировании классов.

Для примера возьмем программу, которая должна создать группу экземпляров электрических
машин.
Многократно вводить (и читать) имя ElectricCar будет очень утомительно. Имени ElectricCar
можно назначить псевдоним в команде import:

"""
from electric_car import ElectricCar as EC

# Теперь можно использовать этот псевдоним (EC) каждый раз, когда необходимо создать
# экземпляр ElectricCar:

my_tesla_666 = EC('tesla_666', 'model-X-666', 2021)
print(my_tesla_666.get_descriptive_name())



""""
!!!   Выработка рабочего процесса  !!!

Рассмотренные возможности структурирования кода имеют важное значение в крупных
проектах. Зная эти возможности можно эффективно организовать свои проекты и лучше
понимать код других разработчиков.
 В будующем желательно ориентироваться на данный подход к организации кода.

"""



print()
print()
print('    - Стандартная библиотека Python')

""""
Стандартная библиотека Python представляет собой набор модулей, включаемых в каждую
установленную копию Python. Чтобы использовать любую функцию или класс из стандартной
библиотеки, достаточно включить простую команду import в начало файла.

Для примера рассмотрим модуль random из стандартной библиотеки Python. Данный модуль
содержит функцию randint(), которая получает два целочисленных аргумента и возвращает
случайно выбранное целое число в диапазоне, определяемом этими двумя числами
(включительно).
В следующем примере генерируется случайное число в диапазоне от 1 до 10:

"""

from random import randint
zzz = randint(1, 100)
print(zzz)

""""
Другая функция из стандартной библиотеки Python choice() получает список или кортеж и
возвращает случайно выбранный элемент:

"""
from random import choice
#players = ['charles', 'martina', 'michael', 'florence', 'eli']

first_up = choice(['charles', 'Artem', 'Leon', 'Eldar', 'martina', 'michael', 'florence', 'eli'])
print(first_up)

""""
ПРИМЕЧАНИЕ. Модули также можно загружать из внешних источников. В конце курса для завершения
работы над проектами мы будем использовать внешние модули.

"""



print()
print()
print('    - Оформление классов')

""""
Оформление классов.

Cтилевое оформлении классов:
* Имена классов
  должны записываться в «верблюжьем» регистре (первая буква каждого слова
  записывается в верхнем регистре, слова не разделяются пробелами. 
  Например, --> FirstWord);
  
* Имена экземпляров и модулей записываются в нижнем регистре с разделением слов символами
  подчеркивания 
  --> (Например, first_word);

* Каждый класс должен иметь строку документации, следующую сразу же за определением класса;
  строка документации должна содержать краткое описание того, что делает класс;
  
* Каждый модуль также должен содержать строку документации с описанием возможных применений
  классов в модуле;

* В классах следует разделять методы одной пустой строкой, а в модулях для разделения классов
  необходимо использовать две пустые строки;

* При импортирования модуля из стандартной библиотеки и модуля разработчика следует начать с
  импортирования модуля стандартной библиотеки, а затем, через пустую строку, импортировать
  модуль разработчика.


"""

print()
print()
print('    - Итоги')

""""
Узнали:
 *как написать собственные классы;
 *как написать методы для создания экземпляров ваших классов с нужными значениями атрибутов;
 *как изменять атрибуты экземпляров напрямую и через методы;

Научились:
 *хранить информацию в классе с использованием атрибутов;
 *наделять свои классы нужным поведением;
 *оформлять свои классы с использованием общепринятых соглашений Python.

Показано, что:
 *наследование может упростить создание логически связанных классов;
 *экземпляры одного класса могут использоваться как атрибуты другого класса для упрощения кода
  классов;
 *хранение классов в модулях и импортирование необходимых классов улучшает организацию
  проектов.

Дальше:
 *работа с файлами;
 *исключения — экземпляры специального класса Python, предназначенного для передачи
  информации о возникающих ошибках.
"""
