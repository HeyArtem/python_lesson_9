''''

Эльдар

Классы в объектно-ориентированном программировании призваны описывать реально существующие
предметы и ситуации для представления их в виде объектов, обладающих как общим поведением, так и
уникальными особенностями.
Создание объекта на основе класса называется созданием экземпляра, т.е. данный объект является
экземпляром класса.
Классы упрощают реализацию серьезных проектов.


Создадим простой класс Dog, представляющий собаку — не какую-то конкретную, а собаку
вообще.
 Перечислим знания о собаках: есть кличка и возраст, умеют садиться и перекатываться
по команде.
 Эти два вида информации (кличка и возраст) и два вида поведения (сидеть и
перекатываться) будут включены в класс Dog, потому что они являются общими для
большинства собак:

'''

class Dog(): # Определяет класс с именем Dog
    ''''  Простая модель собаки '''

    def __init__(self, name, age):
        '''' Инициализирует атрибуты name & age.'''
        self.name = name
        self.age = age

    def sit(self):
        '''' Собака садится по команде '''
        print(f'{self.name} is now setting.')

    def roll_over(self):
        '''' Собака перекатывается по команде '''
        print(f'{self.name} rolled over! ')

''''

имена класса начинаются с символа верхнего регистра.
Круглые скобки в определении класса пусты, потому что класс создается с нуля.

Метод - это функция, являющаяся частью класса; отличается способом вызова. 

Атрибут - это переменная, выступающие в качестве параметра экземпляра класса; отличается способом обращения.

'''

''''
В классах могут использоваться два вида методов:
- метод __init__();
- метод имя_метода().
'''

''''
Метод __init__() — специальный метод, который автоматически выполняется при создании
каждого нового экземпляра данного класса.
 Имя метода начинается и заканчивается двумя символами подчеркивания; нарушение данной
нотации не вызовет данный метод.
 Метод __init__() определяет параметры, с которыми будет работать экземпляр (в
примере: self, name и age).

 Параметр self обязателен в определении метода, потому что при вызове метода
__init__() данному параметру будет передан аргумент автоматически, являющийся ссылкой на
экземпляр. Это позволит получить доступ к атрибутам и методам класса.
 Параметр self должен предшествовать всем остальным параметрам.
 В приведенном примере при создании экземпляра Dog значение self не передается. Мы
передаем лишь кличку и возраст в аргументах.
 Каждая из двух переменных в теле метода __init__() снабжена префиксом self, что дает
доступ к переменным в каждом экземпляре, созданном на основе класса.

 В приведенном примере конструкция self.name = name берет значение, хранящееся в
параметре name, и сохраняет его в атрибуте name, которая затем связывается с создаваемым
экземпляром. Аналогично с self.age = age.

'''

''''
Методы (аналоги функций) при определений должны иметь единственный параметр self.
 В приведенном примере определены два метода sit() и roll_over() с параметром self,
т.к. для из работы не требуется аргументов; они ограничиваются простым выводом сообщения
о том, что собака садится или перекатывается.
 Экземпляры, которые будут созданы позднее, смогут вызывать данные методы.
 
'''



''''
Создание экземпляра класса

Класс — это инструкция по созданию экземпляров данного класса.

В приведенном примере класс Dog — инструкция по созданию экземпляров, представляющих
конкретных собак

Создадим экземпляр, представляющий конкретную собаку:

'''

my_dog = Dog('Willie', 6) # Создаем экземпляр собакки с кличкой Willie и возрастом 6 лет

''''
В процессе обработки строки по созданию экземпляра вызывается метод __init__() класса Dog
с аргументами 'willie' и 6.
Метод __init__() создает экземпляр, представляющий конкретную собаку, и присваивает его
атрибутам name и age переданные значения.
В компьютере выделяется память для хранения экземпляра, представляющего конкретную
собаку; этот экземпляр сохраняется в переменной my_dog. 

Здесь нелишне вспомнить
соглашения по записи имен: обычно считается, что 
 --> имя, начинающееся с символа верхнего регистра (например, Dog), обозначает класс, 
 --> а имя, записанное в нижнем регистре (например, my_dog), обозначает отдельный экземпляр, созданный на базе класса.



Обращение к атрибутам
Для обращения к атрибутам экземпляра может использоваться «точечная» запись

Обратимся к значениям атрибутов экземпляра my_dog:

'''
print('    Обращение к атрибутам')
print(f'My Dog is name is {my_dog.name}.')
print(f'My dog is {my_dog.age} years old.')
# Этот синтаксис показывает, как Python обращается по имени к экземпляру класса для
#  получения значения среди его атрибутов.


print('    Вызов методов')
''''
Для вызова любых методов, определенных в классе применется «точечная» запись

Пример вызова методов, определенных в классе Dog:

'''
my_dog.sit() # вызываем метод sit() через имя my_dog, являющегося экземпляром класса
my_dog.roll_over() # вызываем метод roll_over() через my_dog, являющегося экземпляром класс

# Использование верхнего регистра первой буквы имени класса позволяет создавать производные
# имена экземпляров (нижний регистр)

''''
Создание нескольких экземпляров

На основе класса можно создать столько экземпляров, сколько вам потребуется.

Создадим второй экземпляр Dog с именем your_dog:
'''

print('    - Создание нескольких экземпляров -')
my_dog = Dog('Willie', 6)   # экземпляр с именем Willie
your_dog = Dog('lucy', 3)  # экземпляр с именем Lucy

# Каждый экземпляр обладает своим набором атрибутов
#    и способен выполнять действия из общего набора:

print(f" My dog's name is  {my_dog.name}.")
print(f" My dog is {my_dog.age} years old.")
my_dog.sit()

print(f"\nYour dogs name is {your_dog.name}.")
print(f"Your dod is {your_dog.age} years old.")
your_dog.sit()

мой_пес = Dog('Шарик', 150) # Создаю своего Шарика
print(f"\nМой добрый пёсик {мой_пес.name}")
print(f'Возраст песика {мой_пес.age} годиков')
мой_пес.sit()
мой_пес.roll_over()

# Можно создать сколько угодно экземпляров одного класса при условии, что эти экземпляры
# хранятся в переменных с разными именами или занимают разные позиции в списке либо
# словаре.
# В приведенном примере, если второй собаке будет назначено то же имя и возраст, Python все
# равно создаст отдельный экземпляр класса Dog.




''''
Работа с классами и экземплярами

Свойство классов описывать реальные ситуации обуславливает выполнение задач, связанных с
атрибутами данного экземпляра. Одной из таких задач является изменение атрибутов, связанных с
конкретным экземпляром.


Рассмотрим разработку класса на примере автомобиля.
Этот класс будет содержать информацию о типе машины и метод для вывода краткого описания:

'''

print('    - - Работа с классами и экземплярами')
print('    Рассмотрим разработку класса на примере автомобиля.')

class Car():
    """ Простая модель автомобиля. """
    def __init__(self, make, model, year): # определяется метод __init__() и его список параматров
        """Инициализирует атрибуты описания автомобиля."""
        self.make = make   # сохранение параметра make в атрибуте make класса Car
        self.model = model  # сохранение параметра model в атрибуте model класса Car
        self.year = year  # сохранение параметра year в атрибуте year класса Car

    def get_descriptive_name(self):  # метод, который объединяет год выпуска, фирму-производ, модель
        """Возвращает аккуратно отформатированное описание."""
        long_name = f"{self.year} {self.make} {self.model} "
        return long_name.title() # возвращаемое значение, как в функции


''''

Класс описывает некоторые параметры автомобиля.
Методы данного класса позволяют избавиться от необходимости выводить значение каждого
атрибута по отдельности.


Создадим экземпляр класса Car, которую сохраним в переменной my_new_car:
'''
my_new_car = Car('audi', 'A4', 2019)

''''
Вызовем метод get_descriptive_name(), которое выведет сведения о параметрах автомобиля,
хранящихся в экземпляре my_new_car:
'''
print('   Вызовем метод get_descriptive_name(), которое выведет сведения о параметрах автомобиля,')

print(my_new_car.get_descriptive_name())

моя_тачка = Car('Лада', 'Гранта', 1945)
print(моя_тачка.get_descriptive_name())
# В данном примере мы заставили метод работать с атрибутами экземпляра.
# Далее добавим атрибут, изменяющийся со временем, — в нем будет храниться пробег машины в
# километрах.



print()
print('    Назначение атрибуту значения по умолчанию')
''''
Каждый атрибут класса должен иметь исходное значение, 
даже если оно равно 0 или пустой строке.

В некоторых случаях (например, при задании значений по умолчанию) это исходное значение
есть смысл задавать в теле метода __init__(); в этом случае при создании объекта не
обязательно передавать параметр для этого атрибута.


Добавим атрибут с именем odometer_reading, исходное значение которого всегда равно 0.
Также в класс будет включен метод read_odometer() для чтения текущих показаний одометра:

'''
class Тачки():
    '''' Простая модель автомобиля'''

    def __init__(self, брэнд, модель, год):
        self.брэнд = брэнд
        self.модель = модель
        self.год = год
        self.одометр = 0 # Добавили атрибут, он будет всегда 0 при создании обьектов

    def описательное_имя(self):
        '''' Возвращает аккуратно отформатрованное описание '''

        полное_имя = f"{self.год} {self.брэнд} {self.модель}"
        return полное_имя

    def чтение_одометра(self): # Этот метод упрощает чтение пробега машины.
        '''' Выводит пробег машины в километрах. '''
        print(f" Этот автомобиль имеет {self.одометр} км. пробега ")

# Создадим новый объект
новыйОбъект_мояТачка = Тачки('Москвич', 412, 1975)

'''

Вызовим 2 метода:
1) сведения о параметрах автомобиля, хранящихся в экземпляре my_new_car;
2) сведения о значении одометра, хранящегося в экземпляре my_new_car.

'''
print(новыйОбъект_мояТачка.описательное_имя())
новыйОбъект_мояТачка.чтение_одометра()

''''
Поскольку в методе __init__ не определен параметр атрибута пробега, то при создании
объекта он всегда будет равен 0.
Но, при продаже машин одометр редко показывает ровно 0, поэтому нам понадобится способ
изменения значения этого атрибута.

'''

print()
print('    Изменение значений атрибутов')

''''
Значение атрибута можно изменить одним из трех способов:
изменить его прямо в экземпляре (прямое изменение);
задать значение при помощи метода;
изменить его с приращением при помощи метода.

'''


print(' - Прямое изменение значения атрибута')
''''
Самым простым способом изменения значения атрибута является обращение к нему через экземпляр.
Но, такой способ не рекомендуется!

В следующем примере на одометре напрямую выставляется значение 23:


'''

новыйОбъект_мояТачка.одометр = 23
''''
Здесь была использована «точечная» запись для обращения к атрибуту self.одометр для
присваивания ему значения.

Порядок: берем экземпляр новыйОбъект_мояТачка, находим связанный 
с ним атрибут одометр и
задаем значение атрибута равным 23.

Проверим значение атрибута odometer_reading в экземапляре класса:

'''
новыйОбъект_мояТачка.чтение_одометра()

print(' - Изменение значения атрибута с использованием метода')
''''
Наиболее рационально использовать вспомогательный метод, который обновляет значение атрибута.
Данный метод должен получить в качестве аргумента требуемое значение, и имея доступ к целевому
атрибуту экземпляра, берет обновление атрибута на себя.

В следующем примере в класс включается метод update_odometer() для обновления показаний
одометра:
'''
class Тачки():
    '''' Простая модель автомобиля'''
    def __init__(self, брэнд, модель, год):
        self.брэнд = брэнд
        self.модель = модель
        self.год = год
        self.одометр = 0 # Добавили атрибут, он будет всегда 0 при создании обьектов

    def описательное_имя(self):
        '''' Возвращает аккуратно отформатрованное описание '''
        полное_имя = f"{self.год} {self.брэнд} {self.модель}"
        return полное_имя

    def чтение_одометра(self): # Этот метод упрощает чтение пробега машины.
        '''' Выводит пробег машины в километрах. '''
        print(f" Этот автомобиль имеет {self.одометр} км. пробега ")


    def update_odometr(self, mileage): # добавили метод; получает значение пробега и сохр
        """Устанавливает заданное значение на одометре."""
        self.одометр = mileage
''''
Вызовем метод update_odometer() и передадим ему значение -30 в аргументе (соответствующем
параметру kilometers в определении метода):

'''
новыйОбъект_мояТачка = Тачки('audi', 'a4', 2019)
новыйОбъект_мояТачка.update_odometr(-30)
новыйОбъект_мояТачка.чтение_одометра()

''''
Расширим метод update_odometer() так, чтобы при каждом его вызове проводилась проверка на
предмет сброса показаний одометра:
'''
class Тачки():
    '''' Простая модель автомобиля'''
    def __init__(self, брэнд, модель, год):
        self.брэнд = брэнд
        self.модель = модель
        self.год = год
        self.одометр = 0 # Добавили атрибут, он будет всегда 0 при создании обьектов

    def описательное_имя(self):
        '''' Возвращает аккуратно отформатрованное описание '''
        полное_имя = f"{self.год} {self.брэнд} {self.модель}"
        return полное_имя

    def чтение_одометра(self): # Этот метод упрощает чтение пробега машины.
        '''' Выводит пробег машины в километрах. '''
        print(f" Этот автомобиль имеет {self.одометр} км. пробега ")

    def update_odometer(self, mileage):
        """
        Устанавливает заданное значение на одометре.
        При попытке обратной подкрутки изменение отклоняется.
        """
        if mileage >= self.одометр:  # добавили условие; проверяет новое значение п
            self.одометр = mileage
        else:
            print("Одометр не откатишь назад !!!")

''''
Если новое значение mileage больше или равно текущему, то показания одометра можно
обновить новым значением.
Если новое значение меньше текущего, то получим предупреждение о недопустимости обратной
подкрутки.

'''
print('проверка')
новыйОбъект_мояТачка = Тачки('audi', 'a8', 2020)
новыйОбъект_мояТачка.update_odometer(-30)
новыйОбъект_мояТачка.чтение_одометра()
print('проверка 2 ')
новыйОбъект_мояТачка = Тачки('audi', 'a8', 2020)
новыйОбъект_мояТачка.update_odometer(600)
новыйОбъект_мояТачка.чтение_одометра()


print()
print(' - Изменение значения атрибута с приращением')
''''
Для изменения атрибута на заданное значение без его полного обновления также рекомендуется
применять метод.

Например, после покупки автомобиля пробег увеличился на 100 километров.
Следующий метод получает величину приращения и прибавляет ее к текущим показаниям
одометра:


'''
class Тачки():
    '''' Простая модель автомобиля'''
    def __init__(self, брэнд, модель, год):
        self.брэнд = брэнд
        self.модель = модель
        self.год = год
        self.одометр = 0 # Добавили атрибут, он будет всегда 0 при создании обьектов

    def описательное_имя(self):
        '''' Возвращает аккуратно отформатрованное описание '''
        полное_имя = f"{self.год} {self.брэнд} {self.модель}"
        return полное_имя

    def чтение_одометра(self): # Этот метод упрощает чтение пробега машины.
        '''' Выводит пробег машины в километрах. '''
        print(f" Этот автомобиль имеет {self.одометр} км. пробега ")

    def update_odometer(self, mileage):
        """
        Устанавливает заданное значение на одометре.
        При попытке обратной подкрутки изменение отклоняется.
        """
        if mileage >= self.одометр:  # добавили условие; проверяет новое значение п
            self.одометр = mileage
        else:
            print("Одометр не откатишь назад !!!")
    def increment_odometer(self, kilometers): # добавили метод; получает расстояние в кило
        """Увеличивает показания одометра с заданным приращением."""
        if kilometers >= 0:
            self.одометр += kilometers
        else:
            print("Одометр не откатишь назад никак!!!")
# Создадим экземпляр my_used_car класса Тачки:
my_used_car = Тачки('subaru', 'outback', 2015)
print(my_used_car.описательное_имя()) # пока все четко

''''
Инициализируем показания его одометра значением 23 500; для этого вызывается метод
update_odometer(), которому передается значение 23 500:
'''
my_used_car.update_odometer(23_500)
my_used_car.чтение_одометра() # Контрольная проверка, пока все ок
''''
Вызовем метод increment_odometer(), которому передадим значение 300, чтобы увеличить
показания одометра на 100 километров, пройденные с момента покупки:

'''
print('Увидим, как пробег прибавился:')
my_used_car.increment_odometer(300)
my_used_car.чтение_одометра()

''''
ПРИМЕЧАНИЕ. Подобные методы управляют обновлением внутренних значений экземпляров (таких, как
показания одометра), однако любой пользователь, имеющий доступ к программному коду, сможет
напрямую задать атрибуту любое значение. Эффективная схема безопасности должна уделять особое
внимание таким подробностям, не ограничиваясь простейшими проверками.

В качестве дополнительного упражнения необходимо усовершенствовать метод
increment_odometer(), чтобы он отклонял отрицательные приращения; тем самым будет
предотвращена обратная подкрутка одометра.

'''

print()
print('    Моя попытка сделать защиту от уменьшение пробега ')
class Тачки():
    '''' Простая модель автомобиля'''
    def __init__(self, брэнд, модель, год):
        self.брэнд = брэнд
        self.модель = модель
        self.год = год
        self.одометр = 0 # Добавили атрибут, он будет всегда 0 при создании обьектов

    def описательное_имя(self):
        '''' Возвращает аккуратно отформатрованное описание '''
        полное_имя = f"{self.год} {self.брэнд} {self.модель}"
        return полное_имя

    def чтение_одометра(self): # Этот метод упрощает чтение пробега машины.
        '''' Выводит пробег машины в километрах. '''
        print(f" Этот автомобиль имеет {self.одометр} км. пробега ")

    def update_odometer(self, mileage):
        """
        Устанавливает заданное значение на одометре.
        При попытке обратной подкрутки изменение отклоняется.
        """
        if mileage >= self.одометр:  # добавили условие; проверяет новое значение п
            self.одометр = mileage
        else:
            print("Одометр не откатишь назад !!!")
    def increment_odometer(self, kilometers): # добавили метод; получает расстояние в кило
        """Увеличивает показания одометра с заданным приращением."""
        if kilometers >= 0:
            self.одометр += kilometers
        else:
            print("Одометр не откатишь назад никак!!!")
# Создадим экземпляр my_used_car класса Тачки:
my_used_car = Тачки('лада', 'восьмерка', 2000)
print(my_used_car.описательное_имя()) # пока все четко
my_used_car.update_odometer(200_000) #задали ладе пробег 200 т.км.
my_used_car.чтение_одометра() # Контрольная распечатка


my_used_car.increment_odometer(-100000) # пробуем отмотать 100 т.км.
my_used_car.чтение_одометра() # и увидим, что не отматать




print()
print()
print('     Наследование')
''''
Преимущества работы с классами заключается в том, что работа над новым классом не обязана
начинаться с нуля. Если класс, который вы пишете, представляет собой специализированную версию
ранее написанного класса, вы можете воспользоваться наследованием. Один класс, наследующий от
другого, автоматически получает все атрибуты и методы первого класса.
Исходный класс называется родителем, а новый класс — потомком. Класс-потомок наследует атрибуты
и методы родителя, но при этом также может определять собственные атрибуты и методы.

'''
print('   ** Метод init() класса-потомка')

''''
При написании нового класса на базе существующего класса часто приходится вызывать метод
__init__() класса-родителя.
При этом происходит инициализация любых атрибутов, определенных в методе __init__()
родителя, и эти атрибуты становятся доступными для класса-потомка.

Рассмотрим пример класса, описывающий модель электромобиля.
Класс электромобиля назовем ElectricCar, но так как электромобиль представляет собой
специализированную разновидность автомобиля, то данный класс можно создать на базе класса
Car, написанного ранее.
 В этом случае достаточно добавить в него код атрибутов и поведения, относящегося
только к электромобилям.

Повторим для наглядности код класса Тачки, т.к. определение класса-родителя должно
предшествовать определению класса-потомка в файле.

'''


class Тачки():
    '''' Простая модель автомобиля'''
    def __init__(self, брэнд, модель, год):
        self.брэнд = брэнд
        self.модель = модель
        self.год = год
        self.одометр = 0 # Добавили атрибут, он будет всегда 0 при создании обьектов

    def описательное_имя(self):
        '''' Возвращает аккуратно отформатрованное описание '''
        полное_имя = f"{self.год} {self.брэнд} {self.модель}"
        return полное_имя

    def чтение_одометра(self): # Этот метод упрощает чтение пробега машины.
        '''' Выводит пробег машины в километрах. '''
        print(f" Этот автомобиль имеет {self.одометр} км. пробега ")

    def update_odometer(self, mileage):
        """
        Устанавливает заданное значение на одометре.
        При попытке обратной подкрутки изменение отклоняется.
        """
        if mileage >= self.одометр:  # добавили условие; проверяет новое значение п
            self.одометр = mileage
        else:
            print("Одометр не откатишь назад !!!")
    def increment_odometer(self, kilometers): # добавили метод; получает расстояние в кило
        """Увеличивает показания одометра с заданным приращением."""
        if kilometers >= 0:
            self.одометр += kilometers
        else:
            print("Одометр не откатишь назад никак!!!")

''''

Начнем с создания простой версии класса ElectricCar, который делает все, что делает
класс Car.
В определении потомка имя класса-родителя заключается в круглые скобки.

'''
class ElectricCar(Тачки): # определяется класс-потомок ElectricCar; имя класса-родителя заклю
    """Представляет аспекты машины, специфические для электромобилей."""
    def __init__(self, брэнд, модель, год):  # получает информацию, необходимую для создания
        """инициализирует атрибуты класса-родителя."""
        super().__init__(брэнд, модель, год)


''''
Функция super() — специальная функция, которая позволяет вызвать метод родительского
класса.
Имя super происходит из распространенной терминологии: класс-родитель называется
суперклассом, а класс-потомок — подклассом.

В приведенном примере с использованием функции super() вызвается метод __init__()
класса Тачки, в результате чего экземпляр ElectricCar получает доступ ко всем атрибутам
класса-родителя.

Создадим электромобиль с такой же информацией, которая передается при создании
обычного экземпляра Тачки; создадим экземпляр класса ElectricCar и сохраняем его в
my_tesla.
 Следующая первая строка вызывает метод __init__(), определенный в ElectricCar,
который, в свою очередь, приказывает Python вызвать метод __init__(), определенный в
классе-родителе Тачки. При вызове передаются аргументы 'tesla', 'model s' и 2019.


'''

my_tesla = ElectricCar('tesla', 'model s', 2019)
print(my_tesla.описательное_имя())

''''
Класс ElectricCar еще не содержит никаких специфических для электромобилей атрибутов
или методов, кроме __init__().
Убедившись, что экземпляр ElectricCar работает так же, как экземпляр Car; можно
переходить к определению атрибутов и методов, специфических для модели электромобиля.

'''
print()
print('   ** Определение атрибутов и методов класса-потомка')

''''
Чтобы класс-потомок отличался от класса-родителя следует добавить новые атрибуты и методы.

Добавим атрибут, специфический для электромобилей (например, мощность аккумуляторa) и
метод для вывода информации об этом атрибуте:

'''
class ElectricCar(Тачки):
    """Представляет аспекты машины, специфические для электромобилей."""
    def __init__(self, брэнд, модель, год):
        """
         Инициализирует атрибуты класса-родителя.
         Затем инициализирует атрибуты, специфические для электромобиля.
         """

        super().__init__(брэнд, модель, год)
        self.объем_батареи = 75 # добавлен атрибут; присвоили исходное значение
    def describe_battery(self):
        """Выводит информацию о мощности аккумулятора."""
        print(f"Этот автомобиль имеет батарею {self.объем_батареи}-kWh.")

print(' Проверим работу класса с батареей:')

my_tesla = ElectricCar('tesla', 'models', 2019) # создали экземпляр
print(my_tesla.описательное_имя()) # описание автомобиля
my_tesla.describe_battery() # описание аккумулятора
''''
Атрибут объем_батареи будет присутствовать во всех экземплярах, созданных на основе
класса ElectricCar (но не во всяком экземпляре Car).

Метод describe_battery() выводит описание, которое явно относится только к
электромобилям.

Возможности специализации класса-потомка неограничены. Вы можете добавить сколько
угодно атрибутов и методов.
 В данном примере атрибуты или методы, которые могут принадлежать любой машине (а не
только электромобилю), должны добавляться в класс Car вместо ElectricCar. Тогда эта
информация будет доступна всем пользователям класса Car, а класс ElectricCar будет
содержать только код информации и поведения, специфических для электромобилей.

'''
print('Самомтоятельная работа')
print('      Попробую самостятельно создать класс Пицца')

''''
Шаг 1
Создам класс пицца. 
В нем будет лепешка, соус помодоро, сыр

Шаг 2
Сначало добавлю соль, 
а потом  соль=3гр.

Шаг 3
Создам экземпляр ( потомок) Дьябло с колбасками и перцем

'''
class Pizza():
    def __init__(self, лепешка, соус_помодорро, сыр):
        "Инициализирую атрибуты пиццы"
        self.лепешка = лепешка
        self.соус_помодорро = соус_помодорро
        self.сыр= сыр
    def get_descriptive_name(self):
        """Возвращает аккуратно отформатированное описание."""

        long_name = f"{self.лепешка} {self.соус_помодорро} {self.сыр}"
        return long_name.title()
print('      Шаг 1 Создам и распечатаю мой экземпляр пиццы:')
my_pizza = Pizza('дрожжевая_лепешка', 'томатный_соус', 'Пармезан')
print(my_pizza.get_descriptive_name())


print()
print('    Шаг 2 Сначало добавлю соль, .')

class Pizza():
    def __init__(self, лепешка, соус_помодорро, сыр):
        "Инициализирую атрибуты пиццы"
        self.лепешка = лепешка
        self.соус_помодорро = соус_помодорро
        self.сыр= сыр
        self.соль = 0 # Добавил соль
    def get_descriptive_name(self):
        """Возвращает аккуратно отформатированное описание."""

        long_name = f"{self.лепешка} {self.соус_помодорро} {self.сыр}"
        return long_name.title()

    def количество_соли(self):
        "Метод Выводит количество соли в граммах"
        print(f"В этой пицце {self.соль} грамм соли")

my_pizza = Pizza('дрожжевая_лепешка', 'томатный_соус', 'Пармезан')
print(my_pizza.get_descriptive_name()) # Выведу общую инфу о пицце
my_pizza.количество_соли() # Выведу инфу о соли

print(' Шаг 2. Метод 1. Изменю количество соли прямо в экземпляре (некорректный вариант)')

my_pizza.соль = 6 # Точечное изменение. Обратился к экземпляру и к связ-му Атрибуту
my_pizza.количество_соли() # выведу количество соли

print(' Шаг 2. Метод 2. Задам значение соли (10 гр.) при помощи метода')

class Pizza():
    def __init__(self, лепешка, соус_помодорро, сыр):
        "Инициализирую атрибуты пиццы"
        self.лепешка = лепешка
        self.соус_помодорро = соус_помодорро
        self.сыр= сыр
        self.соль = 0 # Добавил соль
    def get_descriptive_name(self):
        """Возвращает аккуратно отформатированное описание."""

        long_name = f"{self.лепешка} {self.соус_помодорро} {self.сыр}"
        return long_name.title()

    def количество_соли(self):
        "Метод Выводит количество соли в граммах"
        print(f"В этой пицце {self.соль} грамм соли")

    def обновление_соли(self, добавь_соли): # Создал метод, для культурного добавления соли
        self.соль = добавь_соли

my_pizza = Pizza('дрожжевая_лепешка', 'томатный_соус', 'Пармезан')
my_pizza.обновление_соли(+30) # Изменил количество соли

print(my_pizza.get_descriptive_name()) # Выведу общую инфу о пицце
my_pizza.количество_соли() # Выведу количество соли

print(' -->Сделаю защиту, от убавления соли')
class Pizza():
    def __init__(self, лепешка, соус_помодорро, сыр):
        "Инициализирую атрибуты пиццы"
        self.лепешка = лепешка
        self.соус_помодорро = соус_помодорро
        self.сыр= сыр
        self.соль = 10 # По умолчанию в каждой пицце 10 гр. соли!
    def get_descriptive_name(self):
        """Возвращает аккуратно отформатированное описание."""

        long_name = f"{self.лепешка} {self.соус_помодорро} {self.сыр}"
        return long_name.title()

    def количество_соли(self):
        "Метод Выводит количество соли в граммах"
        print(f"В этой пицце {self.соль} грамм соли")

    def обновление_соли(self, добавь_соли): # Создал метод, для культурного добавления соли
        "Код ниже не позволит уменьшить количество соли"
        if добавь_соли >= self.соль:
            self.соль = добавь_соли
        else:
            print("  !!!Уменьшать количество соли нельзя!!!")

my_pizza = Pizza('дрожжевая_лепешка', 'томатный_соус', 'Пармезан')


print(my_pizza.get_descriptive_name()) # Выведу общую инфу о пицце
my_pizza.обновление_соли(5) # Намеренно уменьшаю соль с 10 до 5 гр, и увижу предупреждение
my_pizza.количество_соли() # Выведу количество соли

print(' Шаг 2. Метод 3. Сделаю изменение соли с приращением. По умолчанию будет 10 гр.')

class Pizza():
    def __init__(self, лепешка, соус_помодорро, сыр):
        "Инициализирую атрибуты пиццы"
        self.лепешка = лепешка
        self.соус_помодорро = соус_помодорро
        self.сыр= сыр
        self.соль = 10 # По умолчанию в каждой пицце 10 гр. соли!
    def get_descriptive_name(self):
        """Возвращает аккуратно отформатированное описание."""
        long_name = f"{self.лепешка} {self.соус_помодорро} {self.сыр}"
        return long_name.title()

    def количество_соли(self):
        "Метод Выводит количество соли в граммах"
        print(f"В этой пицце {self.соль} грамм соли")

    def обновление_соли(self, добавь_соли): # Создал метод, для культурного добавления соли
        "Код ниже не позволит уменьшить количество соли"
        if добавь_соли >= self.соль:
            self.соль = добавь_соли
        else:
            print("  !!!Уменьшать количество соли нельзя!!!")

    def прирост_соли(self,подсолили): # Это метод будет увеличивать соль с приращением
        if подсолили >= 0:
            self.соль += подсолили
        else:
            print("!!! Нельзя уменьшать соль!!!")


my_pizza = Pizza('дрожжевая_лепешка', 'томатный_соус', 'Пармезан')

print(my_pizza.get_descriptive_name())  # Выведу общую инфу о пицце
my_pizza.прирост_соли(20) # Добавляю 20 гр. соли
my_pizza.количество_соли()  # Выведу количество соли

print('   # пробую уменьшить количество соли, что бы увидеть, что код не позволит')
print(my_pizza.get_descriptive_name())  # Выведу общую инфу о пицце
my_pizza.прирост_соли(-5) # Добавляю 5 гр. соли
my_pizza.количество_соли()  # Выведу количество соли

print()
print('    НАСЛЕДОВАНИЕ')
print('    Шаг 3 Создам экземпляр ( потомок) Дьябло с колбасками и перцем')

class Pizza():
    def __init__(self, лепешка, соус_помодорро, сыр):
        "Инициализирую атрибуты пиццы"
        self.лепешка = лепешка
        self.соус_помодорро = соус_помодорро
        self.сыр= сыр
        self.соль = 10 # По умолчанию в каждой пицце 10 гр. соли!
    def get_descriptive_name(self):
        """Возвращает аккуратно отформатированное описание."""
        long_name = f"{self.лепешка} {self.соус_помодорро} {self.сыр}"
        return long_name.title()

    def количество_соли(self):
        "Метод Выводит количество соли в граммах"
        print(f"В этой пицце {self.соль} грамм соли")

    def обновление_соли(self, добавь_соли): # Создал метод, для культурного добавления соли
        "Код ниже не позволит уменьшить количество соли"
        if добавь_соли >= self.соль:
            self.соль = добавь_соли
        else:
            print("  !!!Уменьшать количество соли нельзя!!!")

    def прирост_соли(self,подсолили): # Это метод будет увеличивать соль с приращением
        if подсолили >= 0:
            self.соль += подсолили
        else:
            print("!!! Нельзя уменьшать соль!!!")




class Pizza_Diablo(Pizza): # Рождение потомка Дьябло

    def __init__(self, лепешка, соус_помодорро, сыр):
        """инициализирует атрибуты класса-родителя."""
        super().__init__(лепешка, соус_помодорро, сыр)
        self.колбаски = 5
        "Функция super() — специальная функция, которая позволяет вызвать метод родительского класса."

    def количество_колбасок(self):   # Это метод выведет количество колбасок
        print(f" В этой пицце {self.колбаски} колбасок. ")




my_pizza = Pizza_Diablo('лепешка', 'соус_помодорро', 'сыр')  # создали экземпляр
print(my_pizza.get_descriptive_name()) # выведем описание
my_pizza.количество_колбасок()

print('     Конец самостоятельной работы\n Прдолжаю изучать классы')


print()
print('    Переопределение методов класса-родителя')
""""
Любой метод родительского класса, который в моделируемой ситуации делает не то, что нужно, можно
переопределить. Для этого в классе-потомке определяется метод с тем же именем, что и у метода
класса-родителя. Python игнорирует метод родителя и обращает внимание только на метод,
определенный в потомке.

Допустим, в классе Car имеется метод fill_gas_tank(). Для электромобилей заправка
бензином бессмысленна, поэтому этот метод логично переопределить. Например, это можно
сделать так:

"""

class ElectricCar(Тачки):
    """Представляет аспекты машины, специфические для электромобилей."""
    def __init__(self, брэнд, модель, год):
        """
         Инициализирует атрибуты класса-родителя.
         Затем инициализирует атрибуты, специфические для электромобиля.
         """

        super().__init__(брэнд, модель, год)
        self.объем_батареи = 75 # добавлен атрибут; присвоили исходное значение
    def describe_battery(self):
        """Выводит информацию о мощности аккумулятора."""
        print(f"Этот автомобиль имеет батарею {self.объем_батареи}-kWh.")

    def fill_gas_tank(self):  # условно игнорируется метод fill_gas_tank() класса Car;
        """"У Электромобилей нет бензобака """
        print("Этой машиен не нужен бензобак")

""""
С применением наследования потомок сохраняет те аспекты родителя, которые вам нужны, и
переопределяет все ненужное.

"""

print("    Экземпляры как атрибуты")
""""
При моделировании явлений реального мира в программах классы нередко дополняются все большим
количеством подробностей. Списки атрибутов и методов растут, и через какое-то время файлы
становятся длинными и громоздкими. В такой ситуации часть одного класса нередко можно записать в
виде отдельного класса. Большой код разбивается на меньшие классы, которые работают во
взаимодействии друг с другом.

Например, при дальнейшей доработке класса ElectricCar может оказаться, что в нем
появилось слишком много атрибутов и методов, относящихся к аккумулятору.
 В этом случае можно переместить все эти атрибуты и методы в отдельный класс с именем
Battery:

"""
class Battery(): # Определяется новый класс с именем Battery, который не наследует ни один
    """Простая модель аккумулятора электромобиля."""

    def __init__(self, объем_батареи = 75): # перемещен из класса ElectricCar; получает параме
        """Инициализирует атрибуты аккумулятора."""
        self.объем_батареи = объем_батареи


    def describe_battery(self): # метод перемещен из класса ElectricCar.
        """Выводит информацию о мощности аккумулятора."""
        print(f" Этот автомобиль имеет батарею {self.объем_батареи} -kWh")

# Затем экземпляр Battery становится атрибутом класса ElectricCar:

class ElectricCar(Тачки):
    """Представляет аспекты машины, специфические для электромобилей."""
    def __init__(self, брэнд, модель, год):
        """
         Инициализирует атрибуты класса-родителя.
         Затем инициализирует атрибуты, специфические для электромобиля.
         """

        super().__init__(брэнд, модель, год)
        self.battery = Battery()  # добавлен атрибут, которому присвоен экземпляр класса Bat

""""
В последней строке создается новый экземпляр Battery (со значением battery_size по
умолчанию, равным 75, потому что значение не задано) и сохранить его в атрибуте
self.battery. Это будет происходить при каждом вызове __init__(); теперь любой экземпляр
ElectricCar будет иметь автоматически создаваемый экземпляр Battery.

Проверим работу обновленного класса:

"""

my_tesla = ElectricCar('tesla', 'model s', 2019)  # создали экземпляр
print(my_tesla.описательное_имя())          # описание автомобиля
my_tesla.battery.describe_battery()         # описание аккумулятора !!!

""""
В последней строке происходит обращение к экземпляру my_tesla, где переходим к атрибуту
battery и вызываем метод describe_battery(), связанный с экземпляром Battery (в классе
которого определен метод describe_battery())!

Результат выглядит так же, как и в предыдущей версии.
На первый взгляд новый вариант требует большой дополнительной работы, но теперь
аккумулятор можно моделировать с любой степенью детализации без загромождения класса
ElectricCar.
 
 
 Добавим в класс Battery еще один метод, который выводит запас хода на основании
мощности аккумулятора:

"""
class Battery(): # Определяется новый класс с именем Battery, который не наследует ни один
    """Простая модель аккумулятора электромобиля."""

    def __init__(self, объем_батареи = 75): # перемещен из класса ElectricCar; получает параме
        """Инициализирует атрибуты аккумулятора."""
        self.объем_батареи = объем_батареи


    def describe_battery(self): # метод перемещен из класса ElectricCar.
        """Выводит информацию о мощности аккумулятора."""
        print(f" Этот автомобиль имеет батарею {self.объем_батареи} -kWh")

    def get_range(self):  # добавили новый метод; проводит анализ:
        """Выводит приблизительный запас хода для аккумулятора."""

        if self.объем_батареи == 75: # если мощность равна 75 kWh, то запас хода равен 260 миль
            range = 260
        elif self.объем_батареи == 100:  # иначе; при мощности 100 kWh запас хода равен 315 миль
            range = 315

        print(f"Этот автомобиль может проехать {range} миль на полной зарядке.")

my_tesla = ElectricCar('tesla', 'model s', 2019)
print(my_tesla.описательное_имя())
my_tesla.battery.describe_battery()
my_tesla.battery.get_range()

""""
Комментарий.
Для вызова метода, являющийся частью класса, экземпляр которого был определен в другом
классе в качестве атрибута, следует обращаться через имя данного атрибута!

"""

print()
print()
print('    Импортирование классов')
""""
Добавление новой функциональности в классы может формировать слишком длинные програмы. По
аналогии с функциями классы можно хранить в модулях и импортировать нужные классы в основную
программу.

"""
print('    Импортирование одного класса')

''''
Создадим модуль, содержащий только класс (на примере класса Car). Сохраним его в
модуле с именем car.py.

Порядок:
1. http://localhost:8888/tree (http://localhost:8888/tree)
2. New -> Text File
3. Помещаем код
4. File -> Rename -> [имя модуля].py
5. Save

Ниже приведен файл car.py с кодом класса Car:

'''



# Далее импортруем класс Car и создадим экземпляр этого класса:

del Car
from Car import Car # оТкрываем модуль Car и импортируем модуль Car

my_new_car = Car('audi', 'a4', 2019)
print(my_new_car.get_descriptive_name())

my_new_car.odometer_reading = 23
my_new_car.read_odometer()

""""
Перемещая класс в модуль и импортируя этот модуль мы получаем ту же функциональность,
но основной файл программы при этом остается чистым и удобочитаемым.
 Когда большая часть кода храниться в отдельных файлах можно сосредоточиться на
высокоуровневой логике основной программы.

"""