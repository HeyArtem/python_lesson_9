""""
Специальные методы

Специальные методы в Python - это методы, которые отвечают за «стандартные» возможности
объектов и вызываются автоматически при использовани этих возможностей.
Например, выражение a + b, где a и b это числа, преобразуется в такой вызов a.__add__(b),
то есть, специальный метод __add__ отвечает за операцию сложения.

Все специальные методы начинаются и заканчиваются двойным подчеркиванием,
поэтому на английском их часто называют
dunder методы, сокращенно от «double underscore».



Специальные методы часто называют волшебными (magic) методами.



Два подчеркивания перед и после имени
Таким образом обозначаются специальные переменные и методы.

Например, в модуле Python есть такие специальные переменные:

__name__ - эта переменная равна строке __main__,
  когда скрипт запускается напрямую,
  и равна имени модуля, когда импортируется

__file__ - эта переменная равна имени скрипта,
  который был запущен напрямую,
  и равна полному пути к модулю, когда он импортируется


Переменная __name__ чаще всего используется, чтобы указать, что определенная часть кода
должна выполняться, только когда модуль выполняется напрямую:


( https://pyneng.readthedocs.io/ru/latest/book/26_oop_special_methods/underscore_names.html )



Узнать набор методов некоторого объекта можно с помощью встроенной функции
dir():
>>> dir(a) (будет ниже)

"""



print("    пример  __name__ : ")
def multiply(a, b):
    return a*b

if __name__  == "__main__": # что здесь происходит, для чего?
    print(multiply(3, 5))

wtf = multiply(6, 6) # так работает же,,,
print(wtf)


print("пример __file__ :")

import os
""""
os.path 
 является вложенным модулем в модуль os, и реализует некоторые полезные функции для работы с путями.
 
os.path.abspath(path) 
  - возвращает нормализованный абсолютный путь.
"""

print("__file__", __file__)
print(os.path.abspath(__file__))


"""
Кроме того, таким образом в Python обозначаются специальные методы. Эти методы вызываются при 
использовании функций и операторов Python и позволяют реализовать определенный функционал.

Как правило, такие методы не нужно вызывать напрямую. Но, например, при создании своего класса 
может понадобиться описать такой метод, чтобы объект поддерживал какие-то операции в Python.

Например, для того, чтобы можно было получить длину объекта, 
он должен поддерживать метод __len__.

__len__(self)
Возвращает количество элементов в контейнере. Часть протоколов для изменяемого и неизменяемого контейнеров.


"""

"""
Методы __str__, __repr__

Специальные методы __str__ и __repr__ отвечают за строковое представления объекта. 
При этом используются они в разных местах.

Главное отличие от str() в целевой аудитории. 
repr() больше предназначен для машинно-ориентированного вывода 
(более того, это часто должен быть валидный код на Питоне), 
а str() предназначен для чтения людьми

Рассмотрим пример класса IPAddress, который отвечает за представление IPv4 адреса:

"""
print()
print("    пример __str__ :")

class IPAddress:
    def __init__(self, ip):
        self.ip = ip

""""
После создания экземпляров класса, у них есть строковое представление по умолчанию, 
которое выглядит так (этот же вывод отображается при использовании print):
"""


ip1 = IPAddress('10.1.1.1')
ip2 = IPAddress('10.2.2.2')

print('без __str__')
print(ip1) # наверно это вывод номера ячейки? <__main__.IPAddress object at 0x035AC058>
print(ip2)

""""
К сожалению, это представление не очень информативно. 
И было бы лучше, если бы отображалась информация о том, какой именно 
адрес представляет этот экземпляр. 
За отображение информации при применении 
функции str, отвечает специальный метод __str__ 
- как аргумент метод ожидает только экземпляр и должен возвращать строку

"""
class IPAddress:
    def __init__(self, ip):
        self.ip = ip

    def __str__(self):
        return f"IPAddress: {self.ip} "   # будет IPAddress: 10.2.2.2

ip1 = IPAddress('10.1.1.1')
ip2 = IPAddress('10.2.2.2')

print('теперь с применением __str__')
print(ip1)
print(ip2)   # будет IPAddress: 10.2.2.2


""""

__repr__
Второе строковое представление, которое используется в объектах Python, 
отображается при использовании функции repr, 
а также при добавлении объектов в контейнеры типа списков:


"""
print()
print()
print("    пример __repr__ :")

ip_addresses = [ip1, ip2] # список(list)
print('печать списка: ', ip_addresses)  # видимо выводит номера ячеек

print('печать ПЕРВОГО: ',repr(ip1))  # выведет ячейку первого участника списка

''''
За это отображение отвечает метод __repr__, он тоже должен возвращать строку, 
но при этом принято, чтобы метод возвращал строку, 
скопировав которую, можно получить экземпляр класса:

'''
print()
print(' с применением __repr__ через класс: ')

class IPAddress:
    def __init__(self, ip):
        self.ip = ip

    def __str__(self):
        return f" через (str)-->IPAddress: {self.ip} "

    def __repr__(self):
        return f" через (repr)-->IPAddress: ('{self.ip}')"

ip1 = IPAddress('10.1.1.1')
ip2 = IPAddress('10.2.2.2')

ip_addresses = [ip1, ip2]

print(ip_addresses)

print('печать ПЕРВОГО через класс: ',repr(ip1))




print()
print()
""""
Поддержка арифметических операторов

За поддержку арифметических операций также отвечают специальные методы, 
например, за операцию сложения отвечает метод __add__:


__add__(self, other)


Добавим к классу IPAddress поддержку суммирования с числами, 
но чтобы не усложнять реализацию метода, воспользуемся возможностями модуля ipaddress


Функция ipaddress.ip_address() позволяет создавать 
объект IPv4Address или IPv6Address соответственно:

"""

print("    пример __add__ вне класса :")

import ipaddress
ipaddress_1 = ipaddress.ip_address('10.1.1.1')

print(int(ipaddress_1))
'''' получаю число  167837953 '''

print(ipaddress.ip_address(167837953))
'''' из 167837953 получаю  10.1.1.1  '''


print("    пример __add__ в классе")

class IPAddress:
    def __init__(self, ip):
        self.ip = ip

    def __str__(self):
        return f"через (str)-->IPAddress: {self.ip} "

    def __repr__(self):
        return f"через (repr)-->IPAddress: ('{self.ip}')"

    def __add__(self, other):
        ip_int = int(ipaddress.ip_address(self.ip))
        sum_ip_str = str(ipaddress.ip_address(ip_int + other))
        return IPAddress(sum_ip_str)

""""
Переменная ip_int ссылается на значение исходного адреса в десятичном формате. 
а sum_ip_str это строка с IP-адресом полученным в результате сложения двух чисел. 

Как правило, желательно чтобы операция суммирования возвращала экземпляр 
того же класса, поэтому в последней строке метода создается экземпляр класса 
IPAddress и ему как аргумент передается строка с итоговым адресом.

Теперь экземпляры класса IPAddress должны поддерживать 
операцию сложения с числом. 
В результате мы получаем новый экземпляр класса IPAddress.

"""
ip1 = IPAddress('10.1.1.1')
print('вывод ip1 без сложения:', ip1)  # 10.1.1.1

print(ip1 + 1)  # вывод  10.1.1.2
print(ip1 + 2)  #   10.1.1.3
print(ip1 + 3)  #   10.1.1.4
print(ip1 + 5)  #   10.1.1.6


""""
Так как внутри метода используется модуль ipaddress, а он поддерживает 
создание IP-адреса только из десятичного числа, 
надо ограничить метод на работу только с данными типа int. 

Если же второй элемент был объектом другого типа, надо сгенерировать исключение. 
Исключение и сообщение об ошибке возьмем из аналогичной ошибки функции ipaddress.ip_address:



"""
print("    пример сложения с int и float")
a1 = ipaddress.ip_address('10.1.1.1')
print('выведу a1: ', a1)  # вывод: 10.1.1.1

a1_sum = a1 + 5 # складываю с int( 5 ), ошибки не будет
print('выведу a1_sum: ', a1_sum)   # вывод 10.1.1.6

# a2_sum = a1 + 4.0 # здесь умяшлено используется тип float ( 4 )
# print(a2_sum) # я закоментил, т.к. юудет ошибка, я ее скопировал и разместил выше
'''' здесь будет ошибка: скопировано и вставлено:

Traceback (most recent call last):line 259, in <module>
a2_sum = a1 + 4.0 # здесь умяшлено используется тип float

TypeError: unsupported operand type(s) for +: 'IPv4Address' and 'float '''



class IPAddress:
    def __init__(self, ip):
        self.ip = ip

    def __str__(self):
        return f"через (str)-->IPAddress: {self.ip} "

    def __repr__(self):
        return f"через (repr)-->IPAddress: ('{self.ip}')"

    def __add__(self, other):
        if not isinstance(other, int):
            '''' Возвращает флаг, указывающий на то, 
                является ли указанный объект экземпляром указанного класса'''
            raise TypeError(f"неподдерживаемый тип операнда type(s) for +:"
                            f" 'IPAddress' and '{type(other).__name__}'")

        '''' unsupported operand type - неподдерживаемый тип операнда'''


        ip_int = int(ipaddress.ip_address(self.ip))
        sum_ip_str = str(ipaddress.ip_address(ip_int + other))
        return IPAddress(sum_ip_str)
""""
Если второй операнд не является экзепляром класса int, 
генерируется исключение TypeError. 
В исключении выводится информация, что суммирование не поддерживается 
между экземплярами класса IPAddress и экземпляром класса операнда. 

Имя класса получено из самого класса, после обращения к type: type(other).__name__.

Проверка суммирования с десятичным числом и генерации ошибки:

"""

ip1 = IPAddress('10.1.1.1')
print('без сложения: ', ip1)  # будет  10.1.1.1
print(' Выведем ip1 + 5: ', ip1 + 5) # складываем с целым числом Будет   10.1.1.6
#print(' выведем ip1 + 5.0: ', ip1 + 5.0) # складываем с float числом. Будет ошибка, поэтому закоментил

''''
Traceback (most recent call last):
   in <module>
    print(' выведем ip1 + 5.0: ', ip1 + 5.0) # складываем с float числом
  
   in __add__
    raise TypeError(f"неподдерживаемый тип операнда type(s) for +:"
TypeError: неподдерживаемый тип операнда type(s) for +: 'IPAddress' and 'float'


'''



print()
print()
print("    пример dir")

print(dir(ip1))
print(dir(a1))

