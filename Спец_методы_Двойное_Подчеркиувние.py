""""
Специальные методы

Специальные методы в Python - это методы, которые отвечают за «стандартные» возможности
объектов и вызываются автоматически при использовани этих возможностей.
Например, выражение a + b, где a и b это числа, преобразуется в такой вызов a.__add__(b),
то есть, специальный метод __add__ отвечает за операцию сложения.

Все специальные методы начинаются и заканчиваются двойным подчеркиванием,
поэтому на английском их часто называют
dunder методы, сокращенно от «double underscore».



Специальные методы часто называют волшебными (magic) методами.



Два подчеркивания перед и после имени
Таким образом обозначаются специальные переменные и методы.

Например, в модуле Python есть такие специальные переменные:

__name__ - эта переменная равна строке __main__,
  когда скрипт запускается напрямую,
  и равна имени модуля, когда импортируется

__file__ - эта переменная равна имени скрипта,
  который был запущен напрямую,
  и равна полному пути к модулю, когда он импортируется


Переменная __name__ чаще всего используется, чтобы указать, что определенная часть кода
должна выполняться, только когда модуль выполняется напрямую:


( https://pyneng.readthedocs.io/ru/latest/book/26_oop_special_methods/underscore_names.html )

"""

print("пример  __name__ : ")
def multiply(a, b):
    return a*b

if __name__  == "__main__":
    print(multiply(3, 5))



print("пример __file__ :")

import os
print("__file__", __file__)
print(os.path.abspath(__file__))   # !! что за os.path.abspath??? узнать!!!


"""
Кроме того, таким образом в Python обозначаются специальные методы. Эти методы вызываются при 
использовании функций и операторов Python и позволяют реализовать определенный функционал.

Как правило, такие методы не нужно вызывать напрямую. Но, например, при создании своего класса 
может понадобиться описать такой метод, чтобы объект поддерживал какие-то операции в Python.

Например, для того, чтобы можно было получить длину объекта, 
он должен поддерживать метод __len__.

"""

"""
Методы __str__, __repr__

Специальные методы __str__ и __repr__ отвечают за строковое представления объекта. 
При этом используются они в разных местах.

Рассмотрим пример класса IPAddress, который отвечает за представление IPv4 адреса:

"""
print()
print("    пример __str__ :")

class IPAddress:
    def __init__(self, ip):
        self.ip = ip

""""
После создания экземпляров класса, у них есть строковое представление по умолчанию, 
которое выглядит так (этот же вывод отображается при использовании print):
"""


ip1 = IPAddress('10.1.1.1')
ip2 = IPAddress('10.2.2.2')

print('без __str__')
print(ip1)
print(ip2)

""""
К сожалению, это представление не очень информативно. 
И было бы лучше, если бы отображалась информация о том, какой именно 
адрес представляет этот экземпляр. 
За отображение информации при применении 
функции str, отвечает специальный метод __str__ 
- как аргумент метод ожидает только экземпляр и должен возвращать строку

"""
class IPAddress:
    def __init__(self, ip):
        self.ip = ip

    def __str__(self):
        return f"IPAddress: {self.ip} "

ip1 = IPAddress('10.1.1.1')
ip2 = IPAddress('10.2.2.2')

print('теперь с применением __str__')
print(ip1)
print(ip2)


""""

__repr__
Второе строковое представление, которое используется в объектах Python, 
отображается при использовании функции repr, 
а также при добавлении объектов в контейнеры типа списков:


"""
print()
print()
print("    пример __repr__ :")

ip_addresses = [ip1, ip2]
print('печать списка: ', ip_addresses)

print('печать ПЕРВОГО: ',repr(ip1))

''''
За это отображение отвечает метод __repr__, он тоже должен возвращать строку, 
но при этом принято, чтобы метод возвращал строку, 
скопировав которую, можно получить экземпляр класса:

'''

print(' с применением __repr__ через класс: ')

class IPAddress:
    def __init__(self, ip):
        self.ip = ip

    def __str__(self):
        return f" IPAddress -->(str) : {self.ip} "

    def __repr__(self):
        return f" IPAddress -->(repr): ('{self.ip}')"

ip1 = IPAddress('10.1.1.1')
ip2 = IPAddress('10.2.2.2')

ip_addresses = [ip1, ip2]

print(ip_addresses)

print('печать ПЕРВОГО через класс: ',repr(ip1))




print()
print()
""""
Поддержка арифметических операторов

За поддержку арифметических операций также отвечают специальные методы, 
например, за операцию сложения отвечает метод __add__:


__add__(self, other)


Добавим к классу IPAddress поддержку суммирования с числами, 
но чтобы не усложнять реализацию метода, воспользуемся возможностями модуля ipaddress

"""

print("    пример __add__ :")

import ipaddress
ipaddress_1 = ipaddress.ip_address('10.1.1.1')

print(int(ipaddress_1)) # получаю какое то число?
print(ipaddress.ip_address(167837953))

class IPAddress:
    def __init__(self, ip):
        self.ip = ip

    def __str__(self):
        return f" IPAddress -->(str) : {self.ip} "

    def __repr__(self):
        return f" IPAddress -->(repr): ('{self.ip}')"

    def __add__(self, other):
        ip_int = int(ipaddress.ip_address(self.ip))
        sum_ip_str = str(ipaddress.ip_address(ip_int + other))
        return IPAddress(sum_ip_str)

""""
Переменная ip_int ссылается на значение исходного адреса в десятичном формате. 
а sum_ip_str это строка с IP-адресом полученным в результате сложения двух чисел. 
Как правило, желательно чтобы операция суммирования возвращала экземпляр 
того же класса, поэтому в последней строке метода создается экземпляр класса 
IPAddress и ему как аргумент передается строка с итоговым адресом.

Теперь экземпляры класса IPAddress должны поддерживать 
операцию сложения с числом. 
В результате мы получаем новый экземпляр класса IPAddress.



"""