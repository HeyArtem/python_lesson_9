# Мои записи (https://pythonworld.ru/osnovy/inkapsulyaciya-nasledovanie-polimorfizm.html)
#               (https://younglinux.info/oopython/polymorphism.php)

"""
Инкапсуляция
Инкапсуляция — ограничение доступа к составляющим объект компонентам (методам и переменным).
Инкапсуляция делает некоторые из компонент доступными только внутри класса.

Инкапсуляция в Python работает лишь на уровне соглашения между программистами о том,
какие атрибуты являются общедоступными, а какие — внутренними.

Одиночное подчеркивание в начале имени атрибута говорит о том,
что переменная или метод не предназначен для использования
вне методов класса, однако атрибут доступен по этому имени.

"""
print("    Инкапсуляция: ")
print("_одиночное подчеркивание")

class A():
    def _private(self):
        print("Это приватный метод!")

a=A()
a._private() # проверяем доступ по имени


print()
print("__ двойное подчеркивание")
"""
Двойное подчеркивание в начале имени атрибута даёт большую защиту: 
атрибут становится недоступным по этому имени.

"""

class B():
    def __private_W(self):
        print("Это W подчеркивание и более приватный метод! ")

b = B()
#b.__private()   # обращаюсь по имени и будет ошибка Поэтому закоментил
""" 
Код ошибки: 
            Traceback (most recent call last):
            File "C:/Users/artem/PycharmProjects/python_lesson_9/инкапсуляция_и_др.py", line 39, in <module>
            b.__private()
            AttributeError: 'B' object has no attribute '__private'       




Однако полностью это не защищает, так как атрибут 
всё равно остаётся доступным под именем 
_ИмяКласса__ИмяАтрибута:               
            """

print("особое обращение при двойном пождчеркивании _ИмяКласса__ИмяАтрибута")
b._B__private_W()





print()
print()
print("    Наследование")

"""
Наследование
Наследование подразумевает то, что дочерний класс содержит все атрибуты 
родительского класса, при этом некоторые из них могут быть переопределены 
или добавлены в дочернем. 
Например, мы можем создать свой класс, похожий на словарь:

"""

class My_dict(dict):
    def get(self, key, default = 0):
        return dict.get(self, key, default)

a = dict(a=1, b=2)
b = My_dict(a = 1, b= 2)

b['c'] = 4  # что это??, я не помню
print(b)

print(a.get('v')) # что это??, я не помню

print(b.get('v')) # что это??, я не помню

"""
Класс Mydict ведёт себя точно так же, как и словарь, 
за исключением того, что метод get по умолчанию возвращает не None, а 0.

"""



print()
print()
print("    Полиморфизм")
"""
Полиморфизм - разное поведение одного и того же метода в разных классах. 
Например, мы можем сложить два числа, и можем сложить две строки. 

При этом получим разный результат, так как числа и строки являются разными классами.

"""

print(1 + 1)

print("1" + "1")


"""
II вид Полиморфизма

Полиморфизм в объектно-ориентированном программировании – это возможность обработки разных 
типов данных, т. е. принадлежащих к разным классам, с помощью "одно и той же" функции, 
или метода. На самом деле одинаковым является только имя метода, его исходный код 
зависит от класса. Кроме того, результаты работы одноименных методов могут 
существенно различаться. Поэтому в данном контексте под полиморфизмом понимается 
множество форм одного и того же слова – имени метода.


Например, два разных класса содержат метод total, однако инструкции 
каждого предусматривают совершенно разные операции. 
Так в классе T1 – это прибавление 10 к аргументу, 
в T2 – подсчет длины строки символов. В зависимости от того, 
к объекту какого класса применяется метод total, выполняются те или иные инструкции.


"""


class T1:
    n = 10

    def total(self, N):
        self.total = int(self.n) + int(N)


class T2:
    def total(self, s):
        self.total = len(str(s))


t1 = T1()
t2 = T2()
t1.total(45)
t2.total(45)
print(t1.total)  # Вывод: 55
print(t2.total)  # Вывод: 2